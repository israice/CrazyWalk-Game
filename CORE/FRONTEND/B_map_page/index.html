<!DOCTYPE html>
<html lang="en">

<head>
    <!-- Game state is persisted exclusively via Redis (server-side). No client-side storage used. -->
    <meta charset="UTF-8">

    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Map Location</title>
    <script>
        // Mask URL to show only root address
        window.history.replaceState(null, '', '/');
    </script>
    <!-- Preload iPhone Frame (highest priority) -->
    <link rel="preload" href="/B_map_page/components/iphone.png" as="image" fetchpriority="high">

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            /* Fallback */
            height: 100dvh;
            /* Dynamic viewport height */
            overflow: hidden;
            background-color: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
        }

        /* Container for the map content */
        .black-square {
            position: absolute;
            width: 146vh;
            height: 82vh;
            background-color: #050505;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 0;
            overflow: hidden;
            /* Ensure map doesn't spill out */
        }

        /* The Map itself */
        #map {
            width: 100%;
            height: 100%;
            background: #050505;
            opacity: 0;
            transition: opacity 0.8s ease-in-out;
            z-index: 1;
        }

        /* Loader GIF */
        #loading-gif {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            /* Centered in the square */
            width: 150vh;
            /* Adjust size as appropriate */
            height: 150vh;
            object-fit: contain;
            z-index: 10;
            transition: opacity 0.6s ease-out;
        }

        /* The Phone Frame */
        .phone-frame {
            height: 200vh;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-90deg);
            z-index: 9999;
            /* On top of everything */
            pointer-events: none;
        }



        /* Leaflet DivIcon Custom Style for Marker */
        .leaftlet-div-icon {
            background: transparent !important;
            border: none !important;
        }

        /* Mobile Responsive */
        @media (max-width: 1024px) {
            .phone-frame {
                display: none !important;
            }

            .black-square {
                width: 100vw;
                height: 100vh;
                height: 100dvh;
                border-radius: 0;
                transform: translate(-50%, -50%);
            }
        }


        /* Debug Boundary Box */
        .debug-boundary-box {
            display: none;
            border: 2px solid red;
            box-sizing: border-box;
            background: rgba(255, 0, 0, 0.1);
            pointer-events: none;
        }

        /* Show when body has debug-mode class */
        body.debug-mode .debug-boundary-box {
            display: block !important;
        }

        /* Label Styles */
        .leaflet-tooltip.circle-label {
            background: transparent;
            border: none;
            box-shadow: none;
            color: white;
            font-weight: bold;
            font-size: 20px;
            text-shadow: 0 0 2px black;
            pointer-events: none;
            /* Make tooltip transparent to clicks */
        }


        /* Debug Mode Styles */
        body.debug-mode .black-square,
        body.debug-mode #map,
        body.debug-mode .leaflet-container {
            background-color: #001a4d !important;
        }

        /* Tint Tiles Blue in Debug Mode (Invert Light Map to Dark Blue) */
        body.debug-mode .leaflet-tile-pane {
            opacity: 1 !important;
            filter: invert(100%) hue-rotate(180deg) brightness(80%) contrast(110%) !important;
        }

        .street-label-tooltip {
            background: transparent;
            border: none;
            box-shadow: none;
            color: #fff;
            /* White text for Dark Map (Default) */
            font-size: 11px;
            font-weight: bold;
            text-shadow: 0px 0px 2px #000;
            /* Halo */
        }

        /* Invert Label Color in Debug Mode */
        /* Invert Label Color in Debug Mode */
        /* Invert Label Color in Debug Mode */
        body.debug-mode .street-label-tooltip {
            color: #000;
            text-shadow: 0px 0px 2px rgba(255, 255, 255, 0.8);
        }

        /* ERROR SCREEN */
        #error-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #ff0033;
            /* Bright Red */
            z-index: 1000;
            display: none;
            /* Hidden by default */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 5vh;
        }

        #error-screen h1 {
            font-size: 4vh;
            color: white;
            background: none;
            -webkit-text-fill-color: white;
            margin-bottom: 2vh;
        }

        #error-screen p {
            font-size: 2vh;
            color: white;
            opacity: 0.9;
            max-width: 80%;
            margin-bottom: 4vh;
        }

        .btn-retry {
            background: white;
            color: #ff0033;
            border: none;
            padding: 1.5vh 4vh;
            font-size: 2vh;
            font-weight: 700;
            border-radius: 1vh;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s;
        }

        .btn-retry:active {
            transform: scale(0.95);
        }

        /* Allow text selection in popups */
        .leaflet-popup-content {
            -webkit-user-select: text !important;
            -ms-user-select: text !important;
            user-select: text !important;
            cursor: auto;
        }

        /* Poster Styling */
        .poster-overlay {
            pointer-events: none;
            transition: opacity 0.5s ease-in-out;
            z-index: 20;
            /* Above base map tiles (z-index 10-11) */
        }

        /* Version Badge */
        #version-badge {
            position: absolute;
            top: 1vh;
            left: 1vh;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(30, 30, 30, 0.9));
            color: #00ff88;
            font-family: 'Courier New', monospace;
            font-size: 1.5vh;
            font-weight: bold;
            padding: 0.5vh 1vh;
            border-radius: 0.5vh;
            border: 1px solid rgba(0, 255, 136, 0.3);
            z-index: 500;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease-in-out, background 0.3s;
            text-shadow: 0 0 5px rgba(0, 255, 136, 0.5);
        }

        #version-badge.updated {
            background: linear-gradient(135deg, rgba(255, 100, 0, 0.9), rgba(200, 50, 0, 0.9));
            color: #fff;
            border-color: rgba(255, 200, 0, 0.5);
            animation: pulse-version 1s ease-in-out 3;
        }

        @keyframes pulse-version {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }
        }
    </style>
</head>

<body>
    <div class="black-square">
        <div id="map"></div>

        <div id="top-bar-container" style="opacity: 0; transition: opacity 0.8s ease-in-out;"></div>
        <img id="loading-gif" src="/B_map_page/components/earth.gif" alt="Loading...">

        <!-- Red Error Screen -->
        <div id="error-screen">
            <!-- Icon will be inserted dynamically or can use unicode if FontAwesome not loaded, but user has it cached? -->
            <!-- Using SVG or simple text to be safe if FA not present on map page (it wasn't in head) -->
            <div style="font-size: 8vh; color: white; margin-bottom: 2vh;">&#9888;</div>
            <h1>CRITICAL ERROR</h1>
            <p id="error-message">No map data found.</p>
            <button class="btn-retry" id="retry-btn">RETRY</button>
        </div>

        <!-- Version Badge -->
        <div id="version-badge">v0.0.0</div>

    </div>
    <img class="phone-frame" src="/B_map_page/components/iphone.png" alt="Phone Frame">

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <!-- Map Controls Logic -->
    <script src="/B_map_page/components/map_controls.js?v=9"></script>

    <script>
        // Version Badge Loader - Fetches version from README.md
        (async function loadVersionBadge() {
            const versionBadge = document.getElementById('version-badge');

            try {
                // Fetch README.md from server root
                const response = await fetch('/README.md?t=' + Date.now());
                if (!response.ok) throw new Error('README.md not found');

                const text = await response.text();

                // Parse version from git commit line: git commit -m "v0.0.27 - ..."
                const match = text.match(/git commit -m "(v[\d.]+)/m);
                if (!match) throw new Error('Version not found in README.md');

                const currentVersion = match[1];

                // Update badge text
                versionBadge.textContent = currentVersion;
                versionBadge.style.opacity = '1';

            } catch (err) {
                console.warn('DEBUG: Failed to load version badge:', err.message);
                versionBadge.style.display = 'none';
            }
        })();

        document.addEventListener('DOMContentLoaded', () => {
            const mapElement = document.getElementById('map');
            const loadingGif = document.getElementById('loading-gif');
            let hasRevealed = false;

            // Default coordinates
            const DEFAULT_LAT = 32.05688;
            const DEFAULT_LON = 34.76878;
            let isGpsActive = false;
            let hasPreciseFix = false;
            let isDebugActive = false; // New Debug State
            let isPostersDebugActive = false;

            // Location State Persistence
            let collectedCircles = new Set(); // Tracks hidden circle keys: "lat,lon"
            let currentLocationKey = null;    // Current location rounded key: "lat_lon"
            const gameDataCache = new Map();  // Caches game data per location key
            let currentUserPosition = null;   // Current user position {lat, lon}
            const expandedCircles = new Set(); // Track circles that have triggered expansion
            let isRestoringState = false;     // Flag to prevent saving during restoration
            let restoredBlueCircles = [];     // Restored blue circles from saved state

            // PROMO GIF Global Cache
            let promoGifCache = []; // Loaded once on startup
            let promoGifAssignments = new Map(); // PolyID -> GifFilename (Synced with Server)

            // Global Game State (for Redis persistence)
            let currentCircleUid = null;  // UID of circle where player marker is currently positioned
            let cachedGameData = null;    // Complete game data for saving to Redis (accumulated)

            // Helper: Generate location key from coordinates (round to ~100m precision)
            const getLocationKey = (lat, lon) => {
                return `${lat.toFixed(3)}_${lon.toFixed(3)}`;
            };

            const updateAndSaveUserPosition = (marker, lat, lon) => {
                // Update position via controls
                controls.updateUserPosition(marker, lat, lon);

                // Save current position to state
                currentUserPosition = { lat, lon };
                console.log(`DEBUG: Saved user position: ${lat}, ${lon}`);
            };

            // Debounced save for position
            let saveDebounceTimer = null;
            const SAVE_DEBOUNCE_MS = 2000; // 2 seconds

            const debouncedSavePosition = () => {
                if (saveDebounceTimer) {
                    clearTimeout(saveDebounceTimer);
                }

                saveDebounceTimer = setTimeout(async () => {
                    console.log('DEBUG: Saving position to Redis (debounced)...');
                    await saveGlobalState();
                    console.log('DEBUG: Position saved successfully');
                }, SAVE_DEBOUNCE_MS);
            };


            // Helper: Save current location state to server
            // Helper: Save current location state to server
            // REFACTORED: Now delegates to saveGlobalState for unified persistence (Single Redis Key)
            const saveLocationState = async () => {
                // Determine if we should log verbose or just do it silently
                // console.log("DEBUG: Legacy saveLocationState called -> Redirecting to Global Save");
                await saveGlobalState();
            };

            // Helper: Load saved state for a location from server
            const loadLocationState = async (locationKey) => {
                let state = null;

                // Try server ONLY
                try {
                    const response = await fetch(`/api/location_state?location_key=${encodeURIComponent(locationKey)}`);
                    const data = await response.json();
                    if (data.collected_circles && data.collected_circles.length > 0) {
                        state = data;
                        console.log(`DEBUG: Loaded from server for ${locationKey}: ${data.collected_circles.length} circles`);

                        // Restore GIF Assignments
                        if (data.promo_gif_map) {
                            promoGifAssignments = new Map(Object.entries(data.promo_gif_map));
                            console.log(`DEBUG: Restored ${promoGifAssignments.size} GIF assignments from server`);
                        }
                    }
                } catch (err) {
                    console.error('DEBUG: Failed to load from server:', err);
                }

                return state || {
                    collected_circles: [],
                    visible_polygon_ids: [],
                    expanded_circles: []
                };
            };

            // Global helper to load promo GIFs once
            const loadPromoGifs = async () => {
                try {
                    const res = await fetch('/api/promos');
                    if (res.ok) {
                        promoGifCache = await res.json();
                        console.log(`DEBUG: Loaded ${promoGifCache.length} promo GIFs globally`);
                    }
                } catch (e) {
                    console.warn("DEBUG: Failed to load promo GIFs", e);
                }
            };
            loadPromoGifs(); // Trigger load immediately

            // ========== GLOBAL STATE FUNCTIONS ==========

            // Load complete game state from Redis (all geometry + progress)
            const loadGlobalState = async () => {
                try {
                    console.log('GLOBAL_STATE: Checking Redis for saved state...');
                    const response = await fetch('/api/game_state');
                    const state = await response.json();

                    if (state && !state.empty && state.polygons && state.polygons.length > 0) {
                        console.log(`GLOBAL_STATE: Found saved state - ${state.polygons.length} polygons`);
                        return state;
                    }

                    console.log('GLOBAL_STATE: No saved state found - fresh start');
                    return null;
                } catch (err) {
                    console.error('GLOBAL_STATE: Failed to load:', err);
                    return null;
                }
            };

            // Save complete game state to Redis (all geometry + progress)
            const saveGlobalState = async () => {
                if (!cachedGameData || !cachedGameData.polygons || cachedGameData.polygons.length === 0) {
                    console.log('GLOBAL_STATE: No data to save (empty cachedGameData)');
                    return;
                }

                // Build complete state
                const state = {
                    // Geometry (accumulated from cachedGameData)
                    polygons: cachedGameData.polygons || [],
                    white_lines: cachedGameData.white_lines || [],
                    green_circles: cachedGameData.green_circles || [],
                    blue_circles: cachedGameData.blue_circles || [],
                    poster_grid: cachedGameData.poster_grid || currentPosterGrid || [],
                    groups: cachedGameData.groups || [],

                    // Progress
                    collected_circles: Array.from(collectedCircles),
                    visible_polygon_ids: Array.from(visiblePolygonIds),
                    expanded_circles: Array.from(expandedCircles),

                    // Position
                    user_position: currentUserPosition,
                    current_circle_uid: currentCircleUid,

                    // GIF assignments
                    promo_gif_map: Object.fromEntries(promoGifAssignments)
                };

                try {
                    const response = await fetch('/api/game_state', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(state)
                    });
                    const result = await response.json();
                    console.log(`GLOBAL_STATE: Saved - ${result.saved_polygons} polygons, ${result.saved_lines} lines, circle_uid=${currentCircleUid}`);
                } catch (err) {
                    console.error('GLOBAL_STATE: Failed to save:', err);
                }
            };

            // Render game from saved state (without regeneration)
            const renderFromSavedState = async (state) => {
                console.log('GLOBAL_STATE: Rendering from saved state...');

                // Restore progress Sets
                collectedCircles.clear();
                (state.collected_circles || []).forEach(c => collectedCircles.add(c));

                visiblePolygonIds.clear();
                (state.visible_polygon_ids || []).forEach(id => visiblePolygonIds.add(id));

                expandedCircles.clear();
                (state.expanded_circles || []).forEach(c => expandedCircles.add(c));

                // Restore GIF assignments
                if (state.promo_gif_map) {
                    promoGifAssignments = new Map(Object.entries(state.promo_gif_map));
                }

                // Restore user position
                if (state.user_position) {
                    currentUserPosition = state.user_position;

                    // FIX: Move marker IMMEDIATELY to saved position BEFORE rendering
                    // This prevents any logic inside renderGameElements from seeing DEFAULT position
                    console.log(`GLOBAL_STATE: Pre-positioning marker at saved position: ${currentUserPosition.lat}, ${currentUserPosition.lon}`);
                    userMarker.setLatLng([currentUserPosition.lat, currentUserPosition.lon]);
                    map.setView([currentUserPosition.lat, currentUserPosition.lon], 18);
                }

                // Restore circle UID
                if (state.current_circle_uid) {
                    currentCircleUid = state.current_circle_uid;
                }

                // Store poster grid
                if (state.poster_grid) {
                    currentPosterGrid = state.poster_grid;
                }

                // Cache the data for future saves
                cachedGameData = {
                    polygons: state.polygons,
                    white_lines: state.white_lines,
                    green_circles: state.green_circles,
                    blue_circles: state.blue_circles,
                    poster_grid: state.poster_grid,
                    groups: state.groups
                };

                // Build game data object for renderGameElements
                const gameData = {
                    polygons: state.polygons,
                    white_lines: state.white_lines,
                    green_circles: state.green_circles,
                    blue_circles: state.blue_circles,
                    poster_grid: state.poster_grid,
                    groups: state.groups,
                    red_lines: []
                };

                console.log(`GLOBAL_STATE: Restoring ${gameData.polygons.length} polygons, ${collectedCircles.size} collected circles`);

                // Render everything - marker is already at correct position from above
                await renderGameElements(gameData, 'restore');

                // Refine position to exact circle center if UID is available
                if (currentCircleUid && window.allItems) {
                    const circleData = window.allItems.get(currentCircleUid);
                    if (circleData && circleData.lat !== undefined && circleData.lon !== undefined) {
                        console.log(`GLOBAL_STATE: Refining marker to saved circle center ${currentCircleUid}`);
                        updateAndSaveUserPosition(userMarker, circleData.lat, circleData.lon);
                        map.setView([circleData.lat, circleData.lon], 18);
                    } else {
                        console.log(`GLOBAL_STATE: Circle ${currentCircleUid} not found in items, keeping position at ${currentUserPosition.lat}, ${currentUserPosition.lon}`);
                    }
                } else if (currentUserPosition) {
                    console.log(`GLOBAL_STATE: No circle UID saved, marker remains at position ${currentUserPosition.lat}, ${currentUserPosition.lon}`);
                }

                return true;
            };

            // Initialize Map via MapControls (Centralized Logic)
            const controls = new MapControls('map', [DEFAULT_LAT, DEFAULT_LON], {
                defaultZoom: 18,
                minZoom: 3,  // Unrestricted Zoom Out
                maxZoom: 18  // Max Zoom In
            });
            const map = controls.getMap();

            // Create dedicated pane for posters (не затрагивается debug фильтрами)
            map.createPane('postersPane');
            map.getPane('postersPane').style.zIndex = 200; // Ниже overlay pane, но выше tile pane

            // Create dedicated pane for blue circles (всегда поверх белых линий)
            map.createPane('blueCirclesPane');
            map.getPane('blueCirclesPane').style.zIndex = 450; // Выше markerPane (400), поверх белых линий

            // --- QUADRANT NAVIGATION HELPER ---
            let lastInputTime = 0; // Debounce tracker
            let blockMouseEvents = false; // Touch Lockout flag

            // --- DEBUG SELECTION HELPERS (Global to DOMContentLoaded) ---
            // Arrays to support highlighting multiple elements (polygon perimeter + lines + circles)
            let selectedLayers = [];
            let originalStyles = [];

            // Shared Debug Maps (Global to DOMContentLoaded for access by toggleHiddenDebug)
            let _lineLayerMap = null;
            let _circleLayerMap = null;
            let _blueCircleLayerMap = null;
            let _greenCirclesByLine = null;
            let _polygonState = null;

            const resetSelection = () => {
                selectedLayers.forEach((layer, i) => {
                    if (layer && originalStyles[i] && typeof layer.setStyle === 'function') {
                        layer.setStyle(originalStyles[i]);
                    }
                });
                selectedLayers = [];
                originalStyles = [];
            };



            // UI BLOCK CHECKER
            const isUIInteraction = (e) => {
                const target = e.target;
                if (target.tagName === 'BUTTON' || target.tagName === 'INPUT' || target.closest('button')) {
                    return true;
                }
                return false;
            };


            // ------------------------------------------------

            // Initialize Layer Groups
            const groupsLayer = L.layerGroup().addTo(map);
            const detailsLayer = L.layerGroup(); // Don't add to map yet - wait until all elements loaded
            const expandedLayer = L.layerGroup(); // Separate layer for expanded polygons (can be cleared independently)
            let expandedItemUids = new Set(); // Track UIDs of items in expandedLayer
            let expandedCircleCoords = new Set(); // Track coordinates of expanded circles (for collectedCircles cleanup)
            let clearedCircleCoords = new Set(); // Track coordinates that were intentionally cleared (don't reload from server)
            const completedPolygonsLayer = L.layerGroup().addTo(map); // Always visible layer for completed zones
            const postersLayer = L.layerGroup().addTo(map); // Background posters

            // Global circle layer tracking (persist across expand mode)
            const circleLayerMap = new Map(); // coord key -> layer (persists across renders)
            const blueCircleLayerMap = new Map(); // coord key -> blue circle layer
            const lineLayerMap = new Map(); // line id -> layer composite
            const greenCirclesByLine = new Map(); // line id -> [visual layers] (persist across renders)
            const polygonState = new Map(); // polygon id -> state (persist across renders)
            const circleToPolyMap = new Map(); // "lat,lon" -> [polygon IDs] (persist across renders)
            let visiblePolygonIds = new Set(); // Track all visible polygon IDs (initial + expanded)

            // Visibility Rules
            // 1. Details (Polygons, Lines, Circles) -> Visible ONLY at Zoom 18
            controls.addVisibilityRule(detailsLayer, 18);

            // 2. Groups (Monolith) -> Visible ONLY at Zoom 18 (Same as details)
            controls.addVisibilityRule(groupsLayer, 18);

            // 3. Expanded polygons -> Same rules as details
            controls.addVisibilityRule(expandedLayer, 18);

            // Custom Marker Icon (Visual)
            // Goal: Purple Circle (Shadow) is centered on the LatLon (Anchor). GIF stands on top.
            const customIcon = L.divIcon({
                className: 'custom-marker',
                html: `
                    <div style="transform: translate(-50%, -50%); position: relative; display: flex; align-items: center; justify-content: center;">
                        <div style="position: absolute; width: 4vh; height: 4vh; background-color: #9900ff; border: 2px solid white; border-radius: 50%; box-shadow: 0 0 15px #9900ff; opacity: 0.8; transform: perspective(500px) rotateX(45deg);"></div>
                        <img id="marker-gif" src="/B_map_page/components/marker.gif" style="position: relative; z-index: 2; width: 8vh; height: auto; transform: translateY(-25%); bottom: 2vh;">
                    </div>
                `,
                iconSize: null,
                iconAnchor: [0, 0]
            });

            // Create Marker pinned to map
            const userMarker = L.marker([DEFAULT_LAT, DEFAULT_LON], {
                icon: customIcon,
                zIndexOffset: 1000
            }).addTo(map);

            // Handle keyboard movement requests from map_controls.js
            document.addEventListener('map-move-request', (e) => {
                const { lat, lon, direction } = e.detail;
                console.log(`DEBUG: Keyboard move request to ${lat}, ${lon} (direction: ${direction})`);

                // Move marker to new position
                userMarker.setLatLng([lat, lon]);

                // Update current position
                currentUserPosition = { lat, lon };

                // Update circle UID if we moved to a blue circle
                const coordKey = `${lat.toFixed(6)},${lon.toFixed(6)}`;
                if (window.allItems) {
                    // Try to find blue circle at this position
                    for (const [uid, item] of window.allItems.entries()) {
                        if (item.lat !== undefined && item.lon !== undefined) {
                            const itemKey = `${item.lat.toFixed(6)},${item.lon.toFixed(6)}`;
                            if (itemKey === coordKey && uid.startsWith('BLUE_CIRCLE_')) {
                                currentCircleUid = uid;
                                console.log(`DEBUG: Moved to blue circle ${uid}`);
                                break;
                            }
                        }
                    }
                }

                // Trigger debounced save
                debouncedSavePosition();
            });


            // Reveal Map Logic (Visual Transition)
            const topBarContainer = document.getElementById('top-bar-container');
            const revealMap = () => {
                if (hasRevealed) return;
                hasRevealed = true;
                console.log("DEBUG: Revealing Map...");

                // Play Entry Sound
                const entrySound = new Audio('/B_map_page/components/entry_sound.m4a');
                entrySound.play().catch(e => console.warn("DEBUG: Audio play failed:", e));

                map.invalidateSize();
                loadingGif.style.opacity = '0';
                mapElement.style.opacity = '1';
                topBarContainer.style.opacity = '1';
                setTimeout(() => {
                    loadingGif.style.display = 'none';
                    // initPosterGrid moved to renderGameElements after polygons are loaded
                }, 600);
            };

            // --- POSTER GRID LOGIC ---
            const posters = [];
            const REVEAL_MASK_SVG_ID = 'poster-reveal-mask';
            let revealMask = null;
            let revealMaskPath = null;
            let posterSvgOverlay = null; // SVG overlay for posters

            let currentPosterGrid = null; // Store poster grid from server (4 posters)

            const initPosterGrid = (data, mode = 'initial') => {
                const isExpanding = mode === 'expand';
                console.log(`DEBUG: Initializing Poster Grid (mode=${mode}, isExpanding=${isExpanding})...`);

                // During expansion, preserve existing overlay to prevent flicker
                if (!isExpanding) {
                    if (posterSvgOverlay) {
                        console.log("DEBUG: Removing existing poster SVG overlay");
                        posterSvgOverlay.remove();
                        posterSvgOverlay = null;
                    }
                    postersLayer.clearLayers();
                    posters.length = 0;
                } else {
                    console.log("DEBUG: Expansion mode - preserving existing poster overlay");
                }

                if (!currentPosterGrid || currentPosterGrid.length === 0) {
                    console.log("DEBUG: No poster_grid from server");
                    return;
                }

                console.log(`DEBUG: Using server poster grid with ${currentPosterGrid.length} posters`);

                // Find overall bounds for SVG overlay using both posters and polygons
                let minLat = Infinity, maxLat = -Infinity;
                let minLon = Infinity, maxLon = -Infinity;

                currentPosterGrid.forEach(poster => {
                    minLat = Math.min(minLat, poster.min_lat);
                    maxLat = Math.max(maxLat, poster.max_lat);
                    minLon = Math.min(minLon, poster.min_lon);
                    maxLon = Math.max(maxLon, poster.max_lon);
                });

                // Crucial: Expand bounds to include all polygons to prevent clipping
                if (data && data.polygons) {
                    data.polygons.forEach(poly => {
                        poly.coords.forEach(coord => {
                            minLat = Math.min(minLat, coord[0]);
                            maxLat = Math.max(maxLat, coord[0]);
                            minLon = Math.min(minLon, coord[1]);
                            maxLon = Math.max(maxLon, coord[1]);
                        });
                    });
                }

                // Add 5% buffer to prevent edge artifacts
                const latBuffer = (maxLat - minLat) * 0.05;
                const lonBuffer = (maxLon - minLon) * 0.05;
                minLat -= latBuffer; maxLat += latBuffer;
                minLon -= lonBuffer; maxLon += lonBuffer;

                console.log(`DEBUG: SVG Expanded area (with buffer): lat(${minLat.toFixed(5)}, ${maxLat.toFixed(5)}), lon(${minLon.toFixed(5)}, ${maxLon.toFixed(5)})`);

                const svgBounds = L.latLngBounds(
                    [minLat, minLon],  // Southwest corner
                    [maxLat, maxLon]   // Northeast corner
                );

                // EXPANSION MODE: Update existing overlay bounds instead of recreating
                if (isExpanding && posterSvgOverlay) {
                    console.log("DEBUG: Expanding existing poster overlay bounds...");

                    // Get current bounds
                    const currentBounds = posterSvgOverlay.getBounds();

                    // Extend current bounds to include new bounds
                    const extendedBounds = L.latLngBounds(
                        [Math.min(currentBounds.getSouth(), minLat), Math.min(currentBounds.getWest(), minLon)],
                        [Math.max(currentBounds.getNorth(), maxLat), Math.max(currentBounds.getEast(), maxLon)]
                    );

                    console.log(`DEBUG: Extended bounds: lat(${extendedBounds.getSouth().toFixed(5)}, ${extendedBounds.getNorth().toFixed(5)}), lon(${extendedBounds.getWest().toFixed(5)}, ${extendedBounds.getEast().toFixed(5)})`);

                    // Update overlay bounds (this preserves the mask!)
                    posterSvgOverlay.setBounds(extendedBounds);

                    // Posters array is already populated - just update the SVG
                    updatePosterSVG();
                    return;
                }

                // INITIAL MODE: Create new SVG overlay
                const svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg");
                svgElement.style.position = "absolute";
                svgElement.style.top = "0";
                svgElement.style.left = "0";
                svgElement.style.width = "100%";
                svgElement.style.height = "100%";
                svgElement.style.pointerEvents = "none";
                svgElement.setAttribute("viewBox", "0 0 1000 1000");
                svgElement.setAttribute("preserveAspectRatio", "none");
                svgElement.innerHTML = `
                <defs>
                    <mask id="poster-reveal-mask">
                        <rect width="1000" height="1000" fill="black"/>
                        <g id="mask-paths-container" fill="white"></g>
                    </mask>
                </defs>
                <g id="debug-poster-bg" style="display:none; opacity: 0.4; pointer-events: none;"></g>
                <g id="poster-images-container" mask="url(#poster-reveal-mask)"></g>
                <g id="debug-poster-overlay" style="display:none; pointer-events: none;"></g>
            `;

                // Add to map pane with correct bounds
                posterSvgOverlay = L.svgOverlay(svgElement, svgBounds, {
                    interactive: false,
                    pane: 'postersPane'
                }).addTo(map);

                revealMask = svgElement.querySelector('#mask-paths-container');
                const imagesContainer = svgElement.querySelector('#poster-images-container');

                // Create posters from server data
                currentPosterGrid.forEach(poster => {
                    const bounds = [
                        [poster.min_lat, poster.min_lon],
                        [poster.max_lat, poster.max_lon]
                    ];

                    posters.push({
                        bounds,
                        id: poster.id,
                        imageUrl: poster.image_url
                    });

                    console.log(`DEBUG: Poster ${poster.id}: lat(${poster.min_lat.toFixed(5)}, ${poster.max_lat.toFixed(5)}), lon(${poster.min_lon.toFixed(5)}, ${poster.max_lon.toFixed(5)})`);

                    if (poster.position === 5) {
                        const poster5CenterLat = (poster.min_lat + poster.max_lat) / 2;
                        const poster5CenterLon = (poster.min_lon + poster.max_lon) / 2;
                        const userPos = userMarker.getLatLng();
                        console.log(`DEBUG: ========== POSTER #5 CENTER CHECK ==========`);
                        console.log(`DEBUG: Poster #5 center: ${poster5CenterLat.toFixed(6)}, ${poster5CenterLon.toFixed(6)}`);
                        console.log(`DEBUG: User marker pos:  ${userPos.lat.toFixed(6)}, ${userPos.lng.toFixed(6)}`);
                        console.log(`DEBUG: Difference: lat=${Math.abs(poster5CenterLat - userPos.lat).toFixed(6)}, lon=${Math.abs(poster5CenterLon - userPos.lng).toFixed(6)}`);
                        console.log(`DEBUG: =============================================`);
                    }
                });

                console.log(`DEBUG: Created ${posters.length} poster overlays`);
                updatePosterSVG();
            };

            const updatePosterSVG = () => {
                if (!posterSvgOverlay) return;

                const svg = posterSvgOverlay.getElement();
                if (!svg) return;

                const imagesContainer = svg.querySelector('#poster-images-container');
                const bgContainer = svg.querySelector('#debug-poster-bg');
                const overlayContainer = svg.querySelector('#debug-poster-overlay');

                if (!imagesContainer || !bgContainer || !overlayContainer) return;

                // --- DOM RECONCILIATION ---
                // Do NOT clear innerHTML. Instead, diff and update.

                // Get SVG bounds (geographic coordinates)
                const svgBounds = posterSvgOverlay.getBounds();
                const svgMinLat = svgBounds.getSouth();
                const svgMaxLat = svgBounds.getNorth();
                const svgMinLon = svgBounds.getWest();
                const svgMaxLon = svgBounds.getEast();

                const latRange = svgMaxLat - svgMinLat;
                const lonRange = svgMaxLon - svgMinLon;

                const activePosterIds = new Set();

                posters.forEach(p => {
                    activePosterIds.add(p.id);

                    const posterMinLat = p.bounds[0][0];
                    const posterMinLon = p.bounds[0][1];
                    const posterMaxLat = p.bounds[1][0];
                    const posterMaxLon = p.bounds[1][1];

                    const x = ((posterMinLon - svgMinLon) / lonRange) * 1000;
                    const y = ((svgMaxLat - posterMaxLat) / latRange) * 1000;
                    const width = ((posterMaxLon - posterMinLon) / lonRange) * 1000;
                    const height = ((posterMaxLat - posterMinLat) / latRange) * 1000;

                    if (width <= 0 || height <= 0) {
                        return;
                    }

                    // 1. Background Image (Ghost)
                    const bgId = `poster-bg-${p.id}`;
                    let bgImage = bgContainer.querySelector(`#${bgId}`);
                    if (!bgImage) {
                        bgImage = document.createElementNS("http://www.w3.org/2000/svg", "image");
                        bgImage.setAttribute("id", bgId);
                        bgImage.setAttribute("preserveAspectRatio", "none");
                        bgContainer.appendChild(bgImage);
                    }
                    // Update attributes (efficiently)
                    if (bgImage.getAttributeNS("http://www.w3.org/1999/xlink", "href") !== p.imageUrl) {
                        bgImage.setAttributeNS("http://www.w3.org/1999/xlink", "href", p.imageUrl);
                    }
                    bgImage.setAttribute("x", x);
                    bgImage.setAttribute("y", y);
                    bgImage.setAttribute("width", width);
                    bgImage.setAttribute("height", height);

                    // 2. Main Game Image
                    const imgId = `poster-img-${p.id}`;
                    let mainImage = imagesContainer.querySelector(`#${imgId}`);
                    if (!mainImage) {
                        mainImage = document.createElementNS("http://www.w3.org/2000/svg", "image");
                        mainImage.setAttribute("id", imgId);
                        mainImage.setAttribute("opacity", "1.0");
                        mainImage.setAttribute("preserveAspectRatio", "none");
                        imagesContainer.appendChild(mainImage);
                    }
                    if (mainImage.getAttributeNS("http://www.w3.org/1999/xlink", "href") !== p.imageUrl) {
                        mainImage.setAttributeNS("http://www.w3.org/1999/xlink", "href", p.imageUrl);
                    }
                    mainImage.setAttribute("x", x);
                    mainImage.setAttribute("y", y);
                    mainImage.setAttribute("width", width);
                    mainImage.setAttribute("height", height);

                    // 3. Debug Overlay
                    if (isPostersDebugActive) {
                        // For debug overlay, simpler to clear and redraw just for this poster? 
                        // Or we can group them too. Let's group them by poster ID using a group <g>.
                        const debugGroupId = `poster-debug-${p.id}`;
                        let debugGroup = overlayContainer.querySelector(`#${debugGroupId}`);

                        if (!debugGroup) {
                            debugGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
                            debugGroup.setAttribute("id", debugGroupId);
                            overlayContainer.appendChild(debugGroup);

                            // Contents (created once)
                            const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                            rect.setAttribute("fill", "none");
                            rect.setAttribute("stroke", "red");
                            rect.setAttribute("stroke-width", "3");
                            debugGroup.appendChild(rect);

                            const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                            text.setAttribute("fill", "yellow");
                            text.setAttribute("font-size", "13");
                            text.setAttribute("font-weight", "bold");
                            text.setAttribute("text-anchor", "middle");
                            text.setAttribute("dominant-baseline", "middle");
                            text.textContent = `#${p.id}`;
                            debugGroup.appendChild(text);
                        }

                        // Update Group Contents
                        const rect = debugGroup.querySelector('rect');
                        const text = debugGroup.querySelector('text');

                        rect.setAttribute("x", x);
                        rect.setAttribute("y", y);
                        rect.setAttribute("width", width);
                        rect.setAttribute("height", height);

                        text.setAttribute("x", x + width / 2);
                        text.setAttribute("y", y + height / 2);
                    }
                });

                // Cleanup Stale Nodes
                // Helper to remove stale children
                const cleanupContainer = (container, prefix) => {
                    Array.from(container.children).forEach(child => {
                        const id = child.getAttribute("id");
                        if (id && id.startsWith(prefix)) {
                            const posterId = id.replace(prefix, '');
                            if (!activePosterIds.has(posterId)) {
                                child.remove();
                            }
                        }
                    });
                };

                cleanupContainer(bgContainer, 'poster-bg-');
                cleanupContainer(imagesContainer, 'poster-img-');
                cleanupContainer(overlayContainer, 'poster-debug-');

                console.log(`DEBUG: Updated poster layers (Diff Update)`);
            };

            const updatePostersVisibility = () => {
                if (posterSvgOverlay) {
                    const svg = posterSvgOverlay.getElement();
                    if (svg) {
                        const bgContainer = svg.querySelector('#debug-poster-bg');
                        const overlayContainer = svg.querySelector('#debug-poster-overlay');
                        const imagesContainer = svg.querySelector('#poster-images-container');

                        // Main container ALWAYS masked
                        if (imagesContainer) {
                            imagesContainer.setAttribute('mask', 'url(#poster-reveal-mask)');
                        }

                        // Toggle debug layers
                        const display = isPostersDebugActive ? 'inline' : 'none';
                        if (bgContainer) bgContainer.style.display = display;
                        if (overlayContainer) overlayContainer.style.display = display;
                    }
                }
                updatePosterSVG();
                toggleHiddenDebug(isPostersDebugActive);
            };

            const toggleHiddenDebug = (show) => {
                if (!_circleLayerMap || !_polygonState || !_lineLayerMap) return;

                console.log(`DEBUG: Toggling hidden elements: ${show ? 'SHOW ALL' : 'RESTORE HIDDEN'}`);

                // 1. Handle Collected Circles
                collectedCircles.forEach(key => {
                    const layer = _circleLayerMap.get(key);
                    if (layer) {
                        if (show) {
                            // Reveal
                            const isBlue = layer.options.color === 'blue' || (layer.options.fillColor === '#00ccff');
                            layer.setStyle({
                                opacity: 1,
                                fillOpacity: isBlue ? 0.8 : 1
                            });

                            // Restore Blue Circle Tooltip (Number)
                            if (layer.connections !== undefined && !layer.getTooltip()) {
                                layer.bindTooltip(String(layer.connections), {
                                    permanent: true,
                                    direction: 'center',
                                    className: 'circle-label'
                                });
                            }
                        } else {
                            // Re-hide
                            layer.setStyle({ opacity: 0, fillOpacity: 0 });

                            // Remove tooltip again if it was restored
                            if (layer.getTooltip()) {
                                layer.unbindTooltip();
                            }
                        }
                    }
                });

                // 2. Handle Lines from Completed Polygons
                _polygonState.forEach(state => {
                    if (state.current >= state.total && state.lines) {
                        state.lines.forEach(lid => {
                            const lineLayer = _lineLayerMap.get(String(lid));
                            if (lineLayer) {
                                if (show) {
                                    lineLayer.setStyle({ opacity: 1, fillOpacity: 1 }); // Lines usually opacity 1
                                } else {
                                    lineLayer.setStyle({ opacity: 0, fillOpacity: 0 });
                                }
                            }
                        });
                    }
                });
            };

            const addPolygonToMask = (coords) => {
                if (!revealMask) return;

                // We need to project lat/lon to pixel coordinates for the SVG mask
                // BUT Leaflet's L.SVG works better for this.
                // Simpler approach: Use a CSS mask-image with a dynamic SVG.
                // Since Leaflet uses its own panes and transformation, a global SVG is hard to align.

                // REVISED PLAN: Use an L.SVG overlay for the mask that covers the same bounds as the posters.
                // OR even simpler: Just use the polygons themselves as containers for the image background.
                // But user wants a SEAMLESS canvas.

                // Let's use the simplest reliable method: Each completed polygon gets an 'image-reveal' style.
                // We'll use a CSS background with background-attachment: fixed (or simulated via SVG patterns).
            };

            // --- END POSTER GRID LOGIC ---

            // Safety Reveal
            /* REMOVED: Safety reveal is dangerous if data is missing. We want STRICT validation.
            setTimeout(() => {
                if (!hasRevealed) {
                    console.warn("DEBUG: Safety Reveal Triggered (Data took too long)");
                    revealMap();
                }
            }, 30000);
            */

            const showError = (msg) => {
                loadingGif.style.display = 'none';
                mapElement.style.display = 'none';
                if (topBarContainer) topBarContainer.style.display = 'none';

                const errorScreen = document.getElementById('error-screen');
                const errorMessage = document.getElementById('error-message');
                const retryBtn = document.getElementById('retry-btn');

                errorScreen.style.display = 'flex';
                errorMessage.innerHTML = msg;

                retryBtn.onclick = () => {
                    window.location.reload();
                };
            };

            // Reusable function to process coordinates (Logic)
            const processCoordinates = (lat, lon, accuracy, label) => {
                console.log(`DEBUG: [Map Page] Processing ${label} Position: ${lat}, ${lon} (Acc: ${accuracy}m)`);

                // --- SNAP TO NEAREST CIRCLE ---
                if (window.findNearestActiveCircle) {
                    const snapped = window.findNearestActiveCircle(lat, lon);
                    if (snapped) {
                        // 1 degree lat approx 111km -> 111139 meters
                        console.log(`DEBUG: Snapping to circle at ${snapped.lat}, ${snapped.lon} (dist: ${(snapped.dist * 111139).toFixed(1)}m)`);
                        lat = snapped.lat;
                        lon = snapped.lon;
                    } else {
                        console.log("DEBUG: No snap target found. Using raw GPS.");
                    }
                }

                if (label === 'LOW_ACCURACY' && hasPreciseFix) {
                    console.log("DEBUG: Ignoring Low Accuracy update (Precise already found).");
                    return;
                }

                if (label === 'HIGH_ACCURACY') {
                    hasPreciseFix = true;
                }

                // Use Controls to update position (Enforces map follow rules)
                updateAndSaveUserPosition(userMarker, lat, lon);

                // Quality State: 'NONE', 'LOW', 'HIGH'
                // Allows upgrading to High Accuracy if Low was loaded first.
                if (!window.loadedQuality) window.loadedQuality = 'NONE';




                // Background: Send to server
                fetch(`/api/locate?lat=${lat}&lon=${lon}`)
                    .then(res => res.json())
                    .then(data => console.log("DEBUG: Server ack:", data))
                    .catch(err => console.warn("DEBUG: Server sync failed (non-critical):", err));
            };

            const loadGameData = async (lat, lon, forceRebuild = false, mode = 'initial') => {
                console.log("GPS: ========================================");
                console.log(`GPS: Starting polygon generation for (${lat.toFixed(6)}, ${lon.toFixed(6)}) [Mode: ${mode}]`);
                console.log(`GPS: Force rebuild: ${forceRebuild}`);
                console.log("GPS: ========================================");

                // Update to new location key
                const newLocationKey = getLocationKey(lat, lon);
                console.log(`DEBUG: Location key: current=${currentLocationKey}, new=${newLocationKey}, mode=${mode}`);

                // RESTORE STATE FIRST (in initial mode only) - BEFORE checking location switch
                // This ensures we have collectedCircles/visiblePolygonIds populated before making decisions
                if (mode !== 'expand') {
                    // Set flag to prevent saving during restoration
                    isRestoringState = true;
                    console.log(`DEBUG: 🔒 Setting isRestoringState = true (prevent saves during restoration)`);

                    // Restore state from Redis (server) ONLY - no client-side storage
                    try {
                        console.log(`DEBUG: Attempting to restore state from Redis for location: ${newLocationKey}`);
                        const serverState = await loadLocationState(newLocationKey);

                        if (serverState && serverState.visible_polygon_ids && serverState.visible_polygon_ids.length > 0) {
                            console.log(`DEBUG: ✓ Found saved state in Redis: ${serverState.visible_polygon_ids.length} polygons, ${serverState.collected_circles.length} circles`);

                            // Restore polygon IDs
                            visiblePolygonIds.clear();
                            serverState.visible_polygon_ids.forEach(id => visiblePolygonIds.add(id));
                            console.log(`DEBUG: Restored ${visiblePolygonIds.size} polygon IDs from Redis`);

                            // Restore expanded circles
                            if (serverState.expanded_circles && serverState.expanded_circles.length > 0) {
                                expandedCircles.clear();
                                serverState.expanded_circles.forEach(coord => expandedCircles.add(coord));
                                console.log(`DEBUG: Restored ${expandedCircles.size} expanded circles from Redis`);
                            }

                            // Restore collected circles
                            if (serverState.collected_circles && serverState.collected_circles.length > 0) {
                                collectedCircles.clear();
                                serverState.collected_circles.forEach(coord => collectedCircles.add(coord));
                                console.log(`DEBUG: Restored ${collectedCircles.size} collected circles from Redis`);
                            }

                            // Restore blue circles
                            if (serverState.blue_circles && serverState.blue_circles.length > 0) {
                                restoredBlueCircles = serverState.blue_circles;
                                console.log(`DEBUG: Restored ${restoredBlueCircles.length} blue circles from Redis`);
                            } else {
                                restoredBlueCircles = [];
                            }

                            // Restore user position
                            if (serverState.user_position && serverState.user_position.lat !== undefined) {
                                currentUserPosition = serverState.user_position;
                                console.log(`DEBUG: Restored user position from Redis: ${currentUserPosition.lat}, ${currentUserPosition.lon}`);
                            }
                        } else {
                            console.log(`DEBUG: No saved state found in Redis for location: ${newLocationKey}`);
                            restoredBlueCircles = [];
                        }
                    } catch (e) {
                        console.warn("DEBUG: Failed to load state from Redis:", e);
                        restoredBlueCircles = [];
                    }
                } else {
                    // Expand mode - clear restored blue circles
                    restoredBlueCircles = [];
                }


                // In EXPAND mode, keep the same location key (don't switch)
                // In INITIAL mode, save old location and switch to new
                if (mode !== 'expand') {
                    // Check if we're actually switching location or just reloading same location
                    const isSameLocation = (currentLocationKey === newLocationKey);

                    if (!isSameLocation) {
                        // SAVE current location state before switching to new location
                        if (currentLocationKey && collectedCircles.size > 0) {
                            console.log(`DEBUG: Saving state for ${currentLocationKey} before switching...`);
                            await saveLocationState();
                        }

                        // Switch to new location
                        console.log(`DEBUG: Switching location: ${currentLocationKey} -> ${newLocationKey}`);
                        currentLocationKey = newLocationKey;
                        // DON'T clear collectedCircles here - we just restored them above!
                        // collectedCircles = new Set(); // ← REMOVED
                    } else {
                        // Same location - keep collectedCircles (page reload scenario)
                        console.log(`DEBUG: Same location (${currentLocationKey}) - keeping collected circles in memory`);
                    }
                } else {
                    // EXPAND mode: Keep same location key, just save current progress
                    console.log(`DEBUG: Expansion mode - Keeping location key ${currentLocationKey}`);
                    console.log(`DEBUG: Retaining ${collectedCircles.size} collected circles in memory.`);

                    // Save progress to current location (not switching)
                    if (currentLocationKey && collectedCircles.size > 0) {
                        console.log(`DEBUG: Saving expanded state for ${currentLocationKey}...`);
                        await saveLocationState();
                    }
                }

                // Show Loading GIF and dim map (Visual Transition)
                // DON'T dim if expanding (seamless) - User Request "seamless"
                if (mode !== 'expand') {
                    loadingGif.style.display = 'block';
                    loadingGif.style.opacity = '1';
                    mapElement.style.opacity = '0.3';
                    hasRevealed = false;
                } else {
                    console.log("GPS: Expansion mode - keeping map visible.");
                }

                // CHECK CACHE first (unless force rebuild OR expansion)
                // Expansion always fetches fresh data to merge
                if (mode !== 'expand' && !forceRebuild && gameDataCache.has(newLocationKey)) {
                    console.log(`GPS: Using CACHED data for location ${newLocationKey}`);
                    const cachedData = gameDataCache.get(newLocationKey);
                    await renderGameElements(cachedData, mode);
                    revealMap();
                    return;
                }

                // Build URL with optional restored polygon IDs
                let url = `/api/game_data?lat=${lat.toFixed(6)}&lon=${lon.toFixed(6)}&rebuild=${forceRebuild}&mode=${mode}&_t=${Date.now()}`;

                // If initial mode and we have restored polygon IDs, send them to backend
                if (mode !== 'expand' && visiblePolygonIds.size > 0) {
                    const polyIds = Array.from(visiblePolygonIds).join(',');
                    url += `&restored_polygon_ids=${encodeURIComponent(polyIds)}`;
                    console.log(`GPS: Restoring ${visiblePolygonIds.size} previously visible polygons`);
                    console.log(`GPS: Backend polygon IDs being sent: ${polyIds.substring(0, 100)}...`);
                }

                console.log(`GPS: Fetching from ${url}`);

                fetch(url)
                    .then(res => {
                        console.log(`GPS: Response status: ${res.status}`);
                        return res.json();
                    })
                    .then(async data => {
                        console.log("GPS: Server response received");
                        console.log("GPS: Response keys:", Object.keys(data));

                        // Check for error in response (from retry logic)
                        if (data.error) {
                            console.error(`GPS: ========================================`);
                            console.error(`GPS: SERVER ERROR: ${data.error}`);
                            console.error(`GPS: Message: ${data.message}`);
                            console.error(`GPS: ========================================`);
                            showError(`POLYGON GENERATION FAILED<br><br>${data.message}`);
                            return;
                        }

                        // Validate polygons exist
                        if (!data.polygons || data.polygons.length === 0) {
                            console.error("GPS: No polygons in response (empty data)");
                            showError("CRITICAL ERROR<br><br>No polygons found<br>Map cannot be generated");
                            return;
                        }

                        console.log(`GPS: ========================================`);
                        console.log(`GPS: SUCCESS! ${data.polygons.length} polygons received`);
                        console.log(`GPS: Blue circles: ${data.blue_circles?.length || 0}`);
                        console.log(`GPS: White lines: ${data.white_lines?.length || 0}`);
                        console.log(`GPS: Green circles: ${data.green_circles?.length || 0}`);
                        console.log(`GPS: ========================================`);

                        // CACHE the data for this location
                        gameDataCache.set(newLocationKey, data);
                        console.log(`DEBUG: Cached game data for location ${newLocationKey}`);

                        // ACCUMULATE to global cached data for Redis persistence
                        if (mode === 'expand' && cachedGameData) {
                            // Merge new data with existing
                            cachedGameData.polygons = [...(cachedGameData.polygons || []), ...(data.polygons || [])];
                            cachedGameData.white_lines = [...(cachedGameData.white_lines || []), ...(data.white_lines || [])];
                            cachedGameData.green_circles = [...(cachedGameData.green_circles || []), ...(data.green_circles || [])];
                            cachedGameData.blue_circles = [...(cachedGameData.blue_circles || []), ...(data.blue_circles || [])];
                            // Keep original poster_grid
                            console.log(`DEBUG: Accumulated expand data - now ${cachedGameData.polygons.length} total polygons`);
                        } else {
                            // Initial load - replace all
                            cachedGameData = {
                                polygons: data.polygons || [],
                                white_lines: data.white_lines || [],
                                green_circles: data.green_circles || [],
                                blue_circles: data.blue_circles || [],
                                poster_grid: data.poster_grid || [],
                                groups: data.groups || []
                            };
                            console.log(`DEBUG: Set initial cachedGameData - ${cachedGameData.polygons.length} polygons`);
                        }

                        await renderGameElements(data, mode);
                        revealMap();

                        // Save to global Redis state after rendering
                        await saveGlobalState();
                    })
                    .catch(err => {
                        console.error("GPS: ========================================");
                        console.error("GPS: NETWORK ERROR:", err);
                        console.error("GPS: ========================================");
                        showError("CONNECTION ERROR<br><br>Server failed to respond<br>Please try again");
                    });
            };

            // Special version that uses explicit location key for cache lookup (for returning to saved locations)
            const loadGameDataWithKey = async (lat, lon, explicitLocationKey) => {
                console.log("GPS: ========================================");
                console.log(`GPS: Loading with explicit key: ${explicitLocationKey}`);
                console.log("GPS: ========================================");

                // SAVE current location state before switching
                if (currentLocationKey && collectedCircles.size > 0) {
                    console.log(`DEBUG: Saving state for ${currentLocationKey} before switching...`);
                    await saveLocationState();
                }

                // Use explicit key if provided, otherwise calculate
                const targetLocationKey = explicitLocationKey || getLocationKey(lat, lon);
                console.log(`DEBUG: Switching to location key: ${targetLocationKey}`);
                currentLocationKey = targetLocationKey;
                collectedCircles = new Set();

                // Show Loading GIF
                loadingGif.style.display = 'block';
                loadingGif.style.opacity = '1';
                mapElement.style.opacity = '0.3';
                hasRevealed = false;

                // CHECK CACHE with explicit key
                if (gameDataCache.has(targetLocationKey)) {
                    console.log(`GPS: *** USING CACHED DATA for key ${targetLocationKey} ***`);
                    const cachedData = gameDataCache.get(targetLocationKey);
                    await renderGameElements(cachedData);
                    revealMap();
                    return;
                }

                // No cache, fetch new data
                console.log(`GPS: Cache miss for ${targetLocationKey}, fetching fresh data...`);
                const url = `/api/game_data?lat=${lat}&lon=${lon}&rebuild=false&_t=${Date.now()}`;

                fetch(url)
                    .then(res => res.json())
                    .then(async data => {
                        if (data.error || !data.polygons?.length) {
                            showError("Failed to load map data");
                            return;
                        }
                        gameDataCache.set(targetLocationKey, data);
                        await renderGameElements(data);
                        revealMap();
                    })
                    .catch(err => {
                        console.error("GPS: NETWORK ERROR:", err);
                        showError("CONNECTION ERROR");
                    });
            };

            const renderGameElements = async (data, mode = 'initial') => {

                console.log("DEBUG: Starting Render with Progress Tracking...");

                // --- 0. INITIALIZE POSTERS & MASK EARLY ---
                // Store poster grid from server if present
                if (data.poster_grid && data.poster_grid.length > 0) {
                    currentPosterGrid = data.poster_grid;
                    console.log(`DEBUG: Stored ${currentPosterGrid.length} posters from server`);
                } else {
                    console.log("DEBUG: No poster_grid data received from server");
                    currentPosterGrid = null;
                }

                // Initialize poster grid UI and revealMask object
                initPosterGrid(data, mode);

                // Clear layers based on mode
                if (mode !== 'expand') {
                    // Initial mode: clear everything EXCEPT visiblePolygonIds (they were restored from Redis)
                    groupsLayer.clearLayers();
                    detailsLayer.clearLayers();
                    expandedLayer.clearLayers();
                    expandedItemUids.clear();
                    expandedCircleCoords.clear();
                    clearedCircleCoords.clear();
                    // DON'T clear visiblePolygonIds - we just restored them from Redis!
                    // visiblePolygonIds.clear(); ← REMOVED to preserve restored state
                } else {
                    // Expand mode: DON'T clear expandedLayer - accumulate polygons!
                    // We only need to clear the tracking sets for the NEW expansion

                    // Note: We keep expandedItemUids and expandedCircleCoords for tracking
                    // They will accumulate all expanded items across multiple expansions
                    console.log(`DEBUG: Expand mode - accumulating new polygons to existing ${expandedItemUids.size} expanded items`);
                }

                // STRICT VALIDATION
                if (!data || !data.polygons || data.polygons.length === 0) {
                    console.error("CRITICAL: No polygons found in game data.");
                    showError("CRITICAL ERROR:<br>No polygons found.<br>Map cannot be generated.");
                    return;
                }

                // --- 0. DEEP ID INTEGRATION & GLOBAL STORAGE ---
                // Only reset allItems if NOT expanding (expand mode merges with existing)
                if (mode !== 'expand') {
                    window.allItems = new Map();
                } else if (!window.allItems) {
                    window.allItems = new Map();
                }

                // --- 0.5 PREPARE DATA ARRAYS EARLY ---
                // Merge restored blue circles with backend data BEFORE processing
                let localBlueCircles = data.blue_circles || [];
                if (mode === 'initial' && restoredBlueCircles.length > 0) {
                    // Create a map of existing blue circles from backend by coordinates
                    const backendBlueCoords = new Set(
                        localBlueCircles.map(bc => `${bc.lat.toFixed(7)},${bc.lon.toFixed(7)}`)
                    );

                    // Add restored blue circles that are NOT in backend response
                    restoredBlueCircles.forEach(restoredCircle => {
                        const coordKey = `${restoredCircle.lat.toFixed(7)},${restoredCircle.lon.toFixed(7)}`;
                        if (!backendBlueCoords.has(coordKey)) {
                            localBlueCircles.push(restoredCircle);
                        }
                    });

                    console.log(`DEBUG: Merged blue circles - Backend: ${data.blue_circles?.length || 0}, Restored: ${restoredBlueCircles.length}, Total: ${localBlueCircles.length}`);
                }

                // --- HELPER: UPDATE MASK PORTS ---
                // Defined early to be available for applyCollectedState
                const updateMaskPaths = () => {
                    if (!revealMask || !posterSvgOverlay) return;

                    const svgBounds = posterSvgOverlay.getBounds();
                    const svgMinLat = svgBounds.getSouth();
                    const svgMaxLat = svgBounds.getNorth();
                    const svgMinLon = svgBounds.getWest();
                    const svgMaxLon = svgBounds.getEast();
                    const latRange = svgMaxLat - svgMinLat;
                    const lonRange = svgMaxLon - svgMinLon;

                    // Rebuild all paths in the mask
                    revealMask.innerHTML = '';
                    polygonState.forEach(state => {
                        if (state.current >= state.total && state.coords) {
                            try {
                                const points = state.coords.map(p => {
                                    if (!Array.isArray(p) || p.length < 2) return null;
                                    // Scale coordinates to 0-1000 range relative to SVG bounds
                                    const x = ((p[1] - svgMinLon) / lonRange) * 1000;
                                    const y = ((svgMaxLat - p[0]) / latRange) * 1000;
                                    return `${x.toFixed(2)},${y.toFixed(2)}`;
                                }).filter(Boolean).join(' ');

                                const pathData = points ? `M ${points} Z` : '';
                                if (pathData) {
                                    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                                    path.setAttribute("d", pathData);
                                    revealMask.appendChild(path);
                                }
                            } catch (e) {
                                console.warn(`Failed to update mask for polygon ${state.id}:`, e);
                            }
                        }
                    });
                };

                /* REMOVED: Moved to start of renderGameElements
                if (data.poster_grid && data.poster_grid.length > 0) {
                    currentPosterGrid = data.poster_grid;
                    console.log(`DEBUG: Stored ${currentPosterGrid.length} posters from server`);
                } else {
                    console.log("DEBUG: No poster_grid data received from server");
                    currentPosterGrid = null;
                }
                */

                // --- 1. UID/ID MAPPING (Foreign Key Normalization) ---
                const lineIdMap = new Map(); // Old ID (number) -> New UID (string)

                const generateUID = (prefix) => {
                    return `${prefix}_${Math.random().toString(36).substr(2, 9)}`;
                };

                // A. Process White Lines (Dependencies for Polygons/Circles)
                if (data.white_lines) {
                    data.white_lines.forEach(line => {
                        const originalId = line.id;

                        // Check if line already exists by start/end coordinates (reuse UID in expand mode)
                        let existingLine = null;
                        if (line.start && line.end && line.start.length === 2 && line.end.length === 2) {
                            const lineKey = `${line.start[0].toFixed(7)},${line.start[1].toFixed(7)}_${line.end[0].toFixed(7)},${line.end[1].toFixed(7)}`;

                            // Search for existing line with same coordinates in window.allItems
                            for (const [uid, item] of window.allItems.entries()) {
                                if (item.start && item.end && item.start.length === 2 && item.end.length === 2) {
                                    const itemLineKey = `${item.start[0].toFixed(7)},${item.start[1].toFixed(7)}_${item.end[0].toFixed(7)},${item.end[1].toFixed(7)}`;
                                    if (itemLineKey === lineKey && uid.startsWith('WHITE_LINE_')) {
                                        existingLine = { uid, item };
                                        break;
                                    }
                                }
                            }
                        }

                        if (existingLine) {
                            // Reuse existing UID
                            line.uid = existingLine.uid;
                            line.id = existingLine.uid;
                        } else {
                            // Generate new UID
                            line.uid = generateUID('WHITE_LINE');
                            line.id = line.uid; // Swap ID for consistency in app logic
                        }

                        line.original_id = originalId; // Keep for reference if needed

                        if (originalId !== undefined) {
                            lineIdMap.set(Number(originalId), line.uid);
                            lineIdMap.set(String(originalId), line.uid); // String safety
                        }

                        window.allItems.set(line.uid, line);
                        // Track expanded items (only if new)
                        if (mode === 'expand' && !existingLine) {
                            expandedItemUids.add(line.uid);
                        }
                    });
                }

                // B. Process Green Circles (Depend on Lines)
                if (data.green_circles) {
                    data.green_circles.forEach(circle => {
                        // Check if circle already exists by coordinates (reuse UID in expand mode)
                        const coordKey = `${circle.lat.toFixed(6)},${circle.lon.toFixed(6)}`;
                        let existingCircle = null;

                        // Search for existing circle with same coordinates in window.allItems
                        for (const [uid, item] of window.allItems.entries()) {
                            if (item.lat !== undefined && item.lon !== undefined) {
                                const itemKey = `${item.lat.toFixed(6)},${item.lon.toFixed(6)}`;
                                if (itemKey === coordKey && uid.startsWith('GREEN_CIRCLE_')) {
                                    existingCircle = { uid, item };
                                    break;
                                }
                            }
                        }

                        if (existingCircle) {
                            // Reuse existing UID
                            circle.uid = existingCircle.uid;
                            circle.id = existingCircle.uid;
                        } else {
                            // Create new UID
                            circle.uid = generateUID('GREEN_CIRCLE');
                            circle.id = circle.uid;
                        }

                        // Update Reference (Foreign Key)
                        if (circle.line_id !== undefined) {
                            const newRef = lineIdMap.get(circle.line_id);
                            if (newRef) {
                                circle.line_id = newRef;
                            } else {
                                console.warn(`Ref Error: Green Circle ${circle.uid} points to unknown line ${circle.line_id}`);
                            }
                        }

                        window.allItems.set(circle.uid, circle);
                        // Track expanded items (only if new)
                        if (mode === 'expand' && !existingCircle) {
                            expandedItemUids.add(circle.uid);
                        }
                    });
                }

                // C. Process Polygons (Depend on Lines)
                const polyIdMap = new Map(); // Old ID (poly_X) -> New UID (POLYGON_xxx)
                if (data.polygons) {
                    data.polygons.forEach(poly => {
                        const originalId = poly.id; // Save original BACKEND ID (e.g., "poly_4055291218")

                        // UNIFIED ID SCHEME:
                        // Check if polygon already exists by center coordinates (reuse UID in expand mode)
                        let existingPoly = null;
                        if (poly.center && poly.center.length === 2) {
                            const centerKey = `${poly.center[0].toFixed(7)},${poly.center[1].toFixed(7)}`;

                            // Search for existing polygon with same center in window.allItems
                            for (const [uid, item] of window.allItems.entries()) {
                                if (item.center && item.center.length === 2) {
                                    const itemCenterKey = `${item.center[0].toFixed(7)},${item.center[1].toFixed(7)}`;
                                    if (itemCenterKey === centerKey && uid.startsWith('POLYGON_')) {
                                        existingPoly = { uid, item };
                                        break;
                                    }
                                }
                            }
                        }

                        if (existingPoly) {
                            // Reuse existing UID
                            poly.uid = existingPoly.uid;
                            poly.id = existingPoly.uid;
                            poly.backendId = existingPoly.item.backendId || originalId; // Preserve backend ID
                        } else {
                            // Generate random UID for polygons
                            poly.uid = generateUID('POLYGON');
                            poly.id = poly.uid; // UNIFIED.
                            poly.backendId = originalId; // Store original backend ID for restoration
                        }

                        // Store mapping for later use
                        if (originalId !== undefined) {
                            polyIdMap.set(String(originalId), poly.uid);
                        }

                        // Map Wrapper: Update boundary references
                        if (poly.boundary_white_lines) {
                            poly.boundary_white_lines = poly.boundary_white_lines.map(oldId => {
                                const newId = lineIdMap.get(oldId);
                                return newId || oldId;
                            });
                        }

                        window.allItems.set(poly.uid, poly);
                        // Track expanded items (only if new)
                        if (mode === 'expand' && !existingPoly) {
                            expandedItemUids.add(poly.uid);
                        }
                    });
                }

                // D. Process Blue Circles
                if (localBlueCircles && localBlueCircles.length > 0) {
                    localBlueCircles.forEach(circle => {
                        // Check if circle already exists by coordinates (reuse UID in expand mode)
                        const coordKey = `${circle.lat.toFixed(6)},${circle.lon.toFixed(6)}`;
                        let existingCircle = null;

                        // Search for existing circle with same coordinates in window.allItems
                        for (const [uid, item] of window.allItems.entries()) {
                            if (item.lat !== undefined && item.lon !== undefined) {
                                const itemKey = `${item.lat.toFixed(6)},${item.lon.toFixed(6)}`;
                                if (itemKey === coordKey && uid.startsWith('BLUE_CIRCLE_')) {
                                    existingCircle = { uid, item };
                                    break;
                                }
                            }
                        }

                        if (existingCircle) {
                            // Reuse existing UID
                            circle.uid = existingCircle.uid;
                            circle.id = existingCircle.uid;
                        } else {
                            // Create new UID
                            circle.uid = generateUID('BLUE_CIRCLE');
                            circle.id = circle.uid;
                        }

                        // Update connected_polygon_ids to use new UIDs
                        if (circle.connected_polygon_ids) {
                            circle.connected_polygon_ids = circle.connected_polygon_ids.map(oldId => {
                                const newId = polyIdMap.get(String(oldId));
                                return newId || oldId;
                            });
                        }

                        window.allItems.set(circle.uid, circle);
                        // Track expanded items (only if new)
                        if (mode === 'expand' && !existingCircle) {
                            expandedItemUids.add(circle.uid);
                        }
                    });
                }

                // D2. Update White Lines connected_polygon_ids
                if (data.white_lines) {
                    data.white_lines.forEach(line => {
                        if (line.connected_polygon_ids) {
                            line.connected_polygon_ids = line.connected_polygon_ids.map(oldId => {
                                const newId = polyIdMap.get(String(oldId));
                                return newId || oldId;
                            });
                        }
                    });
                }

                // E. Count Blue Circles per Polygon (match coords)
                if (data.polygons && localBlueCircles && localBlueCircles.length > 0) {
                    // Build a Set of blue circle coordinates for fast lookup
                    const blueCircleCoords = new Set(
                        localBlueCircles.map(bc => `${bc.lat.toFixed(7)},${bc.lon.toFixed(7)}`)
                    );

                    data.polygons.forEach(poly => {
                        let count = 0;
                        if (poly.coords) {
                            // DEDUPLICATE polygon coords first (closing vertex = first vertex)
                            const uniquePolyCoords = new Set(
                                poly.coords.map(c => `${c[0].toFixed(7)},${c[1].toFixed(7)}`)
                            );
                            // Count how many unique polygon vertices have a blue circle
                            uniquePolyCoords.forEach(coordKey => {
                                if (blueCircleCoords.has(coordKey)) {
                                    count++;
                                }
                            });
                        }
                        poly.blue_circles_count = count;
                    });
                }

                // F. Enrich White Lines with related elements
                if (data.white_lines && localBlueCircles && localBlueCircles.length > 0 && data.green_circles) {
                    // Build coord -> blue circle UID map
                    const blueByCoord = new Map();
                    localBlueCircles.forEach(bc => {
                        const key = `${bc.lat.toFixed(7)},${bc.lon.toFixed(7)}`;
                        blueByCoord.set(key, bc.uid);
                    });

                    // Build lineId -> green circles list
                    const greenByLine = new Map();
                    data.green_circles.forEach(gc => {
                        if (!greenByLine.has(gc.line_id)) greenByLine.set(gc.line_id, []);
                        greenByLine.get(gc.line_id).push(gc.uid);
                    });

                    data.white_lines.forEach(line => {
                        // Find endpoint blue circles
                        const startKey = `${line.start[0].toFixed(7)},${line.start[1].toFixed(7)}`;
                        const endKey = `${line.end[0].toFixed(7)},${line.end[1].toFixed(7)}`;

                        line.endpoint_blue_circles = [];
                        if (blueByCoord.has(startKey)) line.endpoint_blue_circles.push(blueByCoord.get(startKey));
                        if (blueByCoord.has(endKey)) line.endpoint_blue_circles.push(blueByCoord.get(endKey));

                        // Find green circles on this line
                        line.green_circles_uids = greenByLine.get(line.uid) || [];
                        line.green_circles_count = line.green_circles_uids.length;
                        line.total_circles = line.endpoint_blue_circles.length + line.green_circles_count;
                    });
                }

                // G. Build blue circle data map for neighbor polygon calculations
                const blueCircleDataMap = new Map(); // coord key -> { connections, connected_polygon_ids }
                if (localBlueCircles && localBlueCircles.length > 0) {
                    localBlueCircles.forEach(bc => {
                        const key = `${bc.lat.toFixed(7)},${bc.lon.toFixed(7)}`;
                        blueCircleDataMap.set(key, {
                            id: bc.id,
                            connections: bc.connections || 0,
                            connected_polygon_ids: bc.connected_polygon_ids || [],
                            connected_polygons_count: bc.connected_polygons_count || 0
                        });
                    });
                }

                // H. Calculate neighbor polygons for each polygon - MOVED TO SERVER
                // White Line Data Map is no longer strictly needed for this, but might be useful for other lookups if kept.

                // (Client-side calculation removed to use server-provided data)
                if (data.polygons) {
                    // Ensure arrays exist if server didn't send them (backwards compat)
                    data.polygons.forEach(poly => {
                        if (!poly.neighbor_polygon_ids) poly.neighbor_polygon_ids = [];
                        // We trust server values for counts
                    });
                }

                // STATE STORAGE - Now global (defined at top)
                // polygonState, circleToPolyMap, lineLayerMap are now global and persist across renders

                // Helper to map a circle coord to polygons
                const mapCircleToPolys = (lat, lon, polyList, whiteLineId = -1) => {
                    const key = `${lat.toFixed(6)},${lon.toFixed(6)}`;

                    if (!circleToPolyMap.has(key)) circleToPolyMap.set(key, []);
                    const list = circleToPolyMap.get(key);

                    polyList.forEach(poly => {
                        let isRelevant = false;
                        // Check Green Stickiness (Line ID)
                        // Note: poly.boundary_white_lines and whiteLineId are now UIDs (Strings)
                        if (whiteLineId !== -1 && poly.boundary_white_lines && poly.boundary_white_lines.includes(whiteLineId)) {
                            isRelevant = true;
                        }
                        // Check Blue Stickiness (Vertex Match)
                        else if (whiteLineId === -1) {
                            // This is a blue circle. Check if it matches a vertex of the polygon.
                            const isVertex = poly.coords.some(c => Math.abs(c[0] - lat) < 0.00001 && Math.abs(c[1] - lon) < 0.00001);
                            if (isVertex) isRelevant = true;
                        }

                        if (isRelevant) {
                            if (!list.includes(poly.id)) list.push(poly.id);
                        }
                    });
                };

                // 1. Groups (REMOVED: Technical polygons no longer added to map)
                /*
                if (data.groups) {
                */

                // SHARED DEBUG LOGIC
                // resetSelection is now defined in parent scope

                // Lazy references for maps (filled after circles/lines created)
                // Variables moved to parent scope (DOMContentLoaded)

                const attachDebugClick = (layer, data, type) => {
                    layer.on('click', (e) => {
                        if (!isDebugActive) return;
                        L.DomEvent.stopPropagation(e);

                        // Highlight Logic (Safely)
                        resetSelection();

                        // Redirect to visual proxy if available (for Hit Layers)
                        const targetLayer = layer.visualSibling || layer;

                        // POLYGON LABEL SPECIAL HANDLING
                        if (type === 'Polygon Label' && data.boundary_white_lines) {
                            // 1. Highlight Polygon Perimeter (border only, no fill change)
                            if (typeof targetLayer.setStyle === 'function') {
                                originalStyles.push({
                                    color: targetLayer.options.color,
                                    weight: targetLayer.options.weight
                                });
                                selectedLayers.push(targetLayer);
                                targetLayer.setStyle({ color: 'red', weight: 3 });
                            }

                            // 2. Highlight White Lines
                            if (_lineLayerMap) {
                                data.boundary_white_lines.forEach(lineId => {
                                    const lineLayers = _lineLayerMap.get(String(lineId));
                                    if (lineLayers && lineLayers.visual) {
                                        originalStyles.push({
                                            color: lineLayers.visual.options.color,
                                            weight: lineLayers.visual.options.weight,
                                            dashArray: lineLayers.visual.options.dashArray,
                                            opacity: lineLayers.visual.options.opacity
                                        });
                                        selectedLayers.push(lineLayers.visual);
                                        lineLayers.visual.setStyle({ color: 'red', weight: 3, dashArray: null, opacity: 1 });
                                    }
                                });
                            }

                            // 3. Highlight Green Circles on these lines
                            if (_greenCirclesByLine) {
                                data.boundary_white_lines.forEach(lineId => {
                                    const circles = _greenCirclesByLine.get(String(lineId)); // use String ID
                                    if (circles) {
                                        circles.forEach(circleLayer => {
                                            if (typeof circleLayer.setStyle === 'function') {
                                                originalStyles.push({
                                                    color: circleLayer.options.color,
                                                    weight: circleLayer.options.weight || 1,
                                                    fillColor: circleLayer.options.fillColor,
                                                    fillOpacity: circleLayer.options.fillOpacity
                                                });
                                                selectedLayers.push(circleLayer);
                                                circleLayer.setStyle({ color: 'red', weight: 3 });
                                            }
                                        });
                                    }
                                });
                            }

                            // 4. Highlight Blue Circles (vertices) on polygon coords
                            // Use fuzzy matching since coords may differ in precision
                            if (_blueCircleLayerMap && data.coords) {
                                data.coords.forEach(coord => {
                                    const targetLat = coord[0];
                                    const targetLon = coord[1];

                                    // Fuzzy search: find blue circle within ~5m
                                    for (const [key, blueCircle] of _blueCircleLayerMap) {
                                        const [lat, lon] = key.split(',').map(Number);
                                        const distance = Math.sqrt(
                                            Math.pow(lat - targetLat, 2) + Math.pow(lon - targetLon, 2)
                                        );
                                        // ~0.00005 degrees ≈ 5 meters
                                        if (distance < 0.00005 && !selectedLayers.includes(blueCircle)) {
                                            if (typeof blueCircle.setStyle === 'function') {
                                                originalStyles.push({
                                                    color: blueCircle.options.color,
                                                    weight: blueCircle.options.weight,
                                                    fillColor: blueCircle.options.fillColor,
                                                    fillOpacity: blueCircle.options.fillOpacity
                                                });
                                                selectedLayers.push(blueCircle);
                                                blueCircle.setStyle({ color: 'red', weight: 4 });
                                            }
                                            break; // Found match, stop searching
                                        }
                                    }
                                });
                            }

                            // 5. Highlight the Label Itself (The clicked element)
                            // Note: We polyfilled setStyle on the label marker.
                            if (layer && typeof layer.setStyle === 'function' && !selectedLayers.includes(layer)) {
                                originalStyles.push({ color: 'original' }); // Mock style for restore
                                selectedLayers.push(layer);
                                layer.setStyle({ color: 'red', weight: 3 });
                            }
                        }
                        // WHITE LINE SPECIAL HANDLING
                        else if (type === 'White Line' && data.uid) {
                            // 1. Highlight the Line itself
                            if (_lineLayerMap) {
                                const lineComposite = _lineLayerMap.get(String(data.uid));
                                if (lineComposite && lineComposite.visual) {
                                    originalStyles.push({
                                        color: lineComposite.visual.options.color,
                                        weight: lineComposite.visual.options.weight,
                                        dashArray: lineComposite.visual.options.dashArray,
                                        opacity: lineComposite.visual.options.opacity
                                    });
                                    selectedLayers.push(lineComposite.visual);
                                    lineComposite.visual.setStyle({ color: 'red', weight: 4, dashArray: null, opacity: 1 });
                                }
                            }

                            // 2. Highlight Blue Circles at endpoints
                            if (_blueCircleLayerMap && data.start && data.end) {
                                const startKey = `${data.start[0].toFixed(6)},${data.start[1].toFixed(6)}`;
                                const endKey = `${data.end[0].toFixed(6)},${data.end[1].toFixed(6)}`;

                                [startKey, endKey].forEach(key => {
                                    const blueCircle = _blueCircleLayerMap.get(key);
                                    if (blueCircle && typeof blueCircle.setStyle === 'function') {
                                        if (!selectedLayers.includes(blueCircle)) {
                                            originalStyles.push({
                                                color: blueCircle.options.color,
                                                weight: blueCircle.options.weight,
                                                fillColor: blueCircle.options.fillColor,
                                                fillOpacity: blueCircle.options.fillOpacity
                                            });
                                            selectedLayers.push(blueCircle);
                                            blueCircle.setStyle({ color: 'red', weight: 4 });
                                        }
                                    }
                                });
                            }

                            // 3. Highlight Green Circles on this line
                            if (_greenCirclesByLine) {
                                const greenCircles = _greenCirclesByLine.get(String(data.uid));
                                if (greenCircles) {
                                    greenCircles.forEach(circleLayer => {
                                        if (typeof circleLayer.setStyle === 'function' && !selectedLayers.includes(circleLayer)) {
                                            originalStyles.push({
                                                color: circleLayer.options.color,
                                                weight: circleLayer.options.weight || 1,
                                                fillColor: circleLayer.options.fillColor,
                                                fillOpacity: circleLayer.options.fillOpacity
                                            });
                                            selectedLayers.push(circleLayer);
                                            circleLayer.setStyle({ color: 'red', weight: 3 });
                                        }
                                    });
                                }
                            }
                        }
                        // STANDARD HANDLING for other types
                        else if (typeof targetLayer.setStyle === 'function') {
                            if (type.includes('Circle')) {
                                originalStyles.push({
                                    color: targetLayer.options.color,
                                    weight: targetLayer.options.weight,
                                    fillColor: targetLayer.options.fillColor,
                                    fillOpacity: targetLayer.options.fillOpacity
                                });
                                selectedLayers.push(targetLayer);
                                targetLayer.setStyle({ color: 'red', weight: 4, opacity: 1 });
                            } else if (type.includes('Line')) {
                                originalStyles.push({
                                    color: targetLayer.options.color,
                                    dashArray: targetLayer.options.dashArray,
                                    weight: targetLayer.options.weight,
                                    opacity: targetLayer.options.opacity
                                });
                                selectedLayers.push(targetLayer);
                                targetLayer.setStyle({ color: 'red', dashArray: null, weight: 4, opacity: 1 });
                            } else if (type.includes('Polygon')) {
                                originalStyles.push({
                                    color: targetLayer.options.color,
                                    weight: targetLayer.options.weight,
                                    fillOpacity: targetLayer.options.fillOpacity
                                });
                                selectedLayers.push(targetLayer);
                                targetLayer.setStyle({ color: 'red', weight: 3 });
                            }
                        }

                        // PREPARE DISPLAY DATA
                        // Fix for circular ref if any, and ensure UID is top
                        const debugData = { ...data };
                        const contentObj = { ...data };
                        // Remove large arrays for display if needed, but user wants info.
                        // Ensure UID is visible if property name is different
                        if (data.uid) debugData.uid = data.uid;

                        // prettyJSON will be finalized after stats calculations (for polygons, we add neighbor data)
                        let prettyJSON = JSON.stringify(contentObj, null, 2);
                        const idDisplay = contentObj.uid ? `<b>ID:</b> ${contentObj.uid}<br>` : (contentObj.id ? `<b>ID:</b> ${contentObj.id}<br>` : '');

                        // CHECK TRUE VISIBILITY STATUS FROM GAME STATE (not current opacity)
                        // This accounts for debug mode making hidden elements visible temporarily
                        let status = 'Visible';

                        if (type.includes('Green Circle') || type.includes('Blue Circle')) {
                            // Check if this circle's coordinates are in collectedCircles
                            const lat = data.lat || (data.center && data.center[0]);
                            const lon = data.lon || (data.center && data.center[1]);
                            if (lat !== undefined && lon !== undefined) {
                                const key = `${lat.toFixed(6)},${lon.toFixed(6)}`;
                                if (collectedCircles && collectedCircles.has(key)) {
                                    status = 'Collected';
                                }
                            }
                        } else if (type === 'Polygon Label' || type === 'Polygon') {
                            // Check if polygon is completed
                            const polyId = data.parent_polygon_uid || data.uid || data.id;
                            const pState = polygonState.get(polyId);
                            if (pState && pState.current >= pState.total) {
                                status = 'Completed';
                            }
                        } else if (type === 'White Line') {
                            // White lines are hidden when ALL connected polygons are completed
                            const connectedPolys = data.connected_polygon_ids || [];
                            let allCompleted = connectedPolys.length > 0;
                            for (const polyId of connectedPolys) {
                                const pState = polygonState.get(polyId);
                                if (!pState || pState.current < pState.total) {
                                    allCompleted = false;
                                    break;
                                }
                            }
                            if (allCompleted && connectedPolys.length > 0) {
                                status = 'Hidden (all polys completed)';
                            }
                        }

                        const statusColor = status === 'Visible' ? 'green' : 'orange';
                        const statusHtml = `<br>Status: <b style="color:${statusColor}">${status}</b>`;

                        // CALCULATE STATS FOR POLYGONS
                        let statsHtml = '';
                        if (type === 'Polygon Label' || type === 'Polygon') {
                            // Use actual blue_circles_count (matched from data)
                            const blueCount = data.blue_circles_count || 0;
                            const whiteLinesCount = data.boundary_white_lines ? data.boundary_white_lines.length : 0;
                            const totalPoints = data.total_points || 0;
                            const greenCount = Math.max(0, totalPoints - blueCount); // Green = Total - Blue
                            const mergeCount = data.merge_count || 1;
                            const mergeInfo = mergeCount > 1 ? `🔗 Merged From: <b>${mergeCount}</b> polygons<br>` : '';

                            // Calculate which posters intersect with this polygon
                            const intersectingPosters = [];
                            if (currentPosterGrid && data.coords && data.coords.length > 0) {
                                // Get polygon bounds
                                let polyMinLat = Infinity, polyMaxLat = -Infinity;
                                let polyMinLon = Infinity, polyMaxLon = -Infinity;
                                data.coords.forEach(coord => {
                                    polyMinLat = Math.min(polyMinLat, coord[0]);
                                    polyMaxLat = Math.max(polyMaxLat, coord[0]);
                                    polyMinLon = Math.min(polyMinLon, coord[1]);
                                    polyMaxLon = Math.max(polyMaxLon, coord[1]);
                                });

                                // Check intersection with each poster
                                currentPosterGrid.forEach(poster => {
                                    const intersects = !(polyMaxLat < poster.min_lat ||
                                        polyMinLat > poster.max_lat ||
                                        polyMaxLon < poster.min_lon ||
                                        polyMinLon > poster.max_lon);
                                    if (intersects) {
                                        intersectingPosters.push(poster.id);
                                    }
                                });
                            }

                            const posterInfo = intersectingPosters.length > 0
                                ? `🖼️ Posters: <b>${intersectingPosters.length}</b> <br>`
                                : '';

                            // Neighbor polygon info
                            // Use server-provided line-based stats
                            const connectedLines = data.stats_connected_lines || 0;
                            const missingLines = data.stats_missing_lines || 0; // "Missing Polygons" as per user def

                            const neighborInfo = (connectedLines > 0 || missingLines > 0)
                                ? `<div style="margin-top:4px; padding:4px; background:#fff3e6; border-radius:4px; border:1px solid #ffd591;">
                                    <b>🏘️ Neighbors:</b><br>
                                    ✅ Connected Polygons: <b>${connectedLines}</b><br>
                                    ⚠️ Missing Polygons: <b style="color:${missingLines > 0 ? '#ff4d4f' : '#52c41a'}">${missingLines}</b>
                                   </div>`
                                : '';

                            // Add neighbor IDs to contentObj for JSON copy
                            if (data.neighbor_polygon_ids && data.neighbor_polygon_ids.length > 0) {
                                contentObj.neighbor_polygon_ids = data.neighbor_polygon_ids;
                            }
                            // Keep raw counts for JSON view if needed
                            contentObj.stats_connected_lines = connectedLines;
                            contentObj.stats_missing_lines = missingLines;

                            // Regenerate prettyJSON with new fields
                            prettyJSON = JSON.stringify(contentObj, null, 2);

                            statsHtml = `
                                <div style="margin-bottom:8px; padding:4px; background:#e6f7ff; border-radius:4px; border:1px solid #91d5ff;">
                                    <b>Polygon Stats:</b><br>
                                    ${mergeInfo}
                                    🔵 Blue Circles: <b>${blueCount}</b><br>
                                    ⚪ White Lines: <b>${whiteLinesCount}</b><br>
                                    🟢 Green Circles: <b>${greenCount}</b><br>
                                    ${posterInfo}
                                    --------------------------<br>
                                    ∑ Total Circles: <b>${totalPoints}</b>
                                    ${statusHtml}
                                </div>
                                ${neighborInfo}
                            `;
                        }
                        // STATS FOR WHITE LINES
                        else if (type === 'White Line') {
                            const blueEndpoints = data.endpoint_blue_circles ? data.endpoint_blue_circles.length : 0;
                            const greenCount = data.green_circles_count || 0;
                            const totalCircles = data.total_circles || (blueEndpoints + greenCount);
                            const lineLength = data.length ? data.length.toFixed(2) : '?';
                            const connectedPolyCount = data.connected_polygons_count || 0;
                            const connectedPolyIds = data.connected_polygon_ids ? data.connected_polygon_ids.join(', ') : 'None';

                            const notConnVal = data.stats_not_connected_polygons !== undefined ? data.stats_not_connected_polygons : (2 - connectedPolyCount);
                            const notConnHtml = notConnVal !== undefined ? `Not Connected Polygons: <b>${notConnVal}</b><br>` : '';

                            statsHtml = `
                                <div style="margin-bottom:8px; padding:4px; background:#fff7e6; border-radius:4px; border:1px solid #ffd591;">
                                    <b>Line Stats:</b><br>
                                    📏 Length: <b>${lineLength}m</b><br>
                                    🔵 Blue Endpoints: <b>${blueEndpoints}</b><br>
                                    🟢 Green Circles: <b>${greenCount}</b><br>
                                    Connected Polygons: <b>${data.stats_connected_polygons || connectedPolyCount}</b><br>
                                    ${notConnHtml}
                                    --------------------------<br>
                                    ∑ Total Circles: <b>${totalCircles}</b>
                                    ${statusHtml}
                                </div>
                            `;
                        }
                        // STATS FOR BLUE CIRCLES
                        else if (type.includes('Blue Circle') || (type === 'Start/End Node')) {
                            const connectedCount = data.connected_polygons_count || 0;
                            const connectedIds = data.connected_polygon_ids ? data.connected_polygon_ids.join(', ') : 'None';

                            // 2. BLUE CIRCLE
                            // Check if detailed stats are available (server-side calc)
                            if (data.stats_connected_lines !== undefined) {
                                const notConnPolys = data.stats_not_connected_polygons;
                                const notConnPolysHtml = notConnPolys !== undefined ? `Not Connected Polygons: <b>${notConnPolys}</b><br>` : '';

                                statsHtml = `
                                <div style="margin-bottom:8px; padding:4px; background:#e6f7ff; border-radius:4px; border:1px solid #91d5ff;">
                                    <b>Blue Circle Stats:</b><br>
                                    Connected lines: <b>${data.stats_connected_lines}</b><br>
                                    Not Connected lines: <b>${data.stats_not_connected_lines}</b><br>
                                    Connected Polygons: <b>${data.stats_connected_polygons}</b><br>
                                    ${notConnPolysHtml}
                                    ${statusHtml}
                                </div>
                                `;
                            } else {
                                // Fallback
                                statsHtml = `
                                <div style="margin-bottom:8px; padding:4px; background:#e6f7ff; border-radius:4px; border:1px solid #91d5ff;">
                                    <b>Blue Circle Stats:</b><br>
                                    Connections: <b>${data.connections || '?'}</b><br>
                                    🔗 Polygons: <b>${connectedCount}</b>
                                    ${statusHtml}
                                </div>
                                `;
                            }
                        }
                        // STATS FOR GREEN CIRCLES
                        else if (type.includes('Green Circle')) {
                            const connectedCount = data.connected_polygons_count || 0;
                            const lineId = data.line_id || '?';

                            const notConnVal = data.stats_not_connected_polygons !== undefined ? data.stats_not_connected_polygons : (2 - connectedCount);
                            const notConnHtml = notConnVal !== undefined ? `Not Connected Polygons: <b>${notConnVal}</b>` : '';

                            statsHtml = `
                                <div style="margin-bottom:8px; padding:4px; background:#e6ffe6; border-radius:4px; border:1px solid #91ff91;">
                                    <b>Green Circle Stats:</b><br>
                                    📍 Line ID: <b style="font-size:10px;">${lineId}</b><br>
                                    Connected Polygons: <b>${data.stats_connected_polygons || connectedCount}</b><br>
                                    ${notConnHtml}
                                    ${statusHtml}
                                </div>
                            `;
                        }

                        const container = document.createElement('div');
                        container.innerHTML = `
                            <div style="font-size: 11px; line-height: 1.2; color: #333;">
                                ${idDisplay}
                                <b>Type:</b> ${type}<br>
                                ${statsHtml}
                                <details>
                                    <summary style="cursor:pointer; color:#0066cc; margin:4px 0;">Show Raw Data</summary>
                                    <pre style="background:#f0f0f0; padding:4px; border-radius:4px; max-height:150px; overflow:auto; margin:4px 0;">${prettyJSON}</pre>
                                </details>
                                <button style="width:100%; cursor:pointer; padding:4px;">Copy Data</button>
                            </div>
                        `;

                        const btn = container.querySelector('button');
                        btn.onclick = () => {
                            navigator.clipboard.writeText(prettyJSON).then(() => {
                                btn.innerText = "Copied!";
                                setTimeout(() => btn.innerText = "Copy Data", 2000);
                            });
                        };

                        L.popup({ minWidth: 200 })
                            .setLatLng(e.latlng)
                            .setContent(container)
                            .openOn(map);
                    });
                };

                // Helper to set lazy references after maps are created
                const setDebugMaps = (lineMap, circleMap, blueMap, greenByLine, polyState) => {
                    _lineLayerMap = lineMap;
                    _circleLayerMap = circleMap;
                    _blueCircleLayerMap = blueMap;
                    _greenCirclesByLine = greenByLine;
                    _polygonState = polyState;
                };

                // Map click to clear selection
                map.on('click', () => {
                    if (isDebugActive) {
                        resetSelection();
                        map.closePopup();
                    }
                });

                // PROMO: Fetch list of GIFS
                // PROMO: Fetch list of GIFS (Removed: Now using global promoGifCache)
                // We rely on promoGifCache being populated.

                // Helper to pick random GIF with persistence
                // Helper to pick random GIF with persistence
                // Helper to pick random GIF with persistence (REDIS Version)
                const getAssignedGif = (polyId) => {
                    if (promoGifCache.length === 0) return null;

                    if (!polyId) return null;

                    // Use Global Map (Synced with Redis)
                    if (promoGifAssignments.has(String(polyId))) {
                        return promoGifAssignments.get(String(polyId));
                    }

                    // Assign new random GIF
                    const idx = Math.floor(Math.random() * promoGifCache.length);
                    const newGif = promoGifCache[idx];

                    // Save to Map (will be pushed to server on next Save)
                    promoGifAssignments.set(String(polyId), newGif);
                    console.log(`DEBUG: Assigned NEW GIF for ${polyId}: ${newGif}`);
                    return newGif;
                };

                // 2. Polygons (Init State)
                // Backend now filters data for initial mode, so we can use it directly
                let localPolys = data.polygons || [];
                let localGreenCircles = data.green_circles || [];
                let localWhiteLines = data.white_lines || [];

                console.log(`DEBUG: Received from backend - Polygons: ${localPolys.length}, White Lines: ${localWhiteLines.length}, Green Circles: ${localGreenCircles.length}, Blue Circles: ${localBlueCircles.length}`);

                // Choose target layer based on mode
                const targetLayer = (mode === 'expand') ? expandedLayer : detailsLayer;
                console.log(`DEBUG: Using ${mode === 'expand' ? 'expandedLayer' : 'detailsLayer'} for rendering`);

                localPolys.forEach(poly => {
                    // Track this polygon as visible (use backend ID for server matching)
                    if (poly.backendId) {
                        visiblePolygonIds.add(poly.backendId);
                    } else {
                        console.warn(`WARNING: Polygon ${poly.id} has no backendId, using frontend UID`);
                        visiblePolygonIds.add(poly.id);
                    }

                    // Skip if polygon already rendered (expand mode reuses existing polygons)
                    if (polygonState.has(poly.id)) {
                        console.log(`DEBUG: Polygon ${poly.id} already exists, skipping rendering`);
                        return; // Don't re-render, keep existing state
                    }

                    // Create Visual
                    const pLayer = L.polygon(poly.coords, {
                        color: 'transparent', fillColor: 'transparent', fillOpacity: 0, weight: 0
                    }).addTo(targetLayer);

                    // attachDebugClick(pLayer, poly, 'Polygon'); // Removed per user request

                    // Calculate positions for both circles
                    // Large circle stays at polygon center
                    // Small circle is positioned on the circumference of large circle, towards longest edge

                    const centerPos = poly.center;
                    const direction = poly.label_direction || { angle: 0 };

                    // Large circle radius in pixels = 30px
                    // Small circle should be positioned at distance = 30px + 15px = 45px from center
                    // Using iconAnchor offset to position small circle relative to large circle's center

                    // Calculate pixel offset for small circle based on angle
                    // radius = 45px (30px large radius + 15px small radius)
                    const radius_px = 45;
                    const angle = direction.angle || 0;

                    // Calculate offset in pixels
                    // Note: In screen coordinates, Y increases downward
                    const offsetX = Math.cos(angle) * radius_px;
                    const offsetY = -Math.sin(angle) * radius_px; // Negative because screen Y is inverted

                    // Check if polygon is already completed (all circles collected)
                    // DYNAMIC CALCULATION: Count how many poly coordinates are in collectedCircles
                    let savedCount = 0;
                    if (poly.coords && poly.coords.length > 0) {
                        savedCount = poly.coords.filter(c => {
                            const key = `${c[0].toFixed(6)},${c[1].toFixed(6)}`;
                            return collectedCircles.has(key);
                        }).length;
                    }
                    const isCompleted = savedCount >= poly.total_points;

                    // Create Large Promo Circle at polygon center (ONLY if not completed OR in debug mode)
                    const gifFile = poly.promo_gif;
                    let pPromo = null;
                    if (gifFile && (!isCompleted || isPostersDebugActive)) {
                        pPromo = L.marker([centerPos[0], centerPos[1]], {
                            icon: L.divIcon({
                                className: 'poly-promo',
                                html: `<div style="background:white; border-radius:50%; width:60px; height:60px; overflow:hidden; border:2px solid white; box-shadow:0 0 5px rgba(0,0,0,0.5); display:flex; align-items:center; justify-content:center;">
                                        <img src="/GAME_PROMOS/${gifFile}" style="width:100%; height:100%; object-fit:cover;">
                                      </div>`,
                                iconSize: [60, 60],
                                iconAnchor: [30, 30] // Centered at polygon center
                            }),
                            interactive: true
                        }).addTo(targetLayer);
                    }

                    // Create Small Percentage Circle on circumference of large circle (ONLY if not completed OR in debug mode)
                    let pLabel = null;
                    if (!isCompleted || isPostersDebugActive) {
                        // Calculate initial percentage from saved progress
                        const initialPercent = poly.total_points > 0 ? Math.floor((savedCount / poly.total_points) * 100) : 0;
                        pLabel = L.marker([centerPos[0], centerPos[1]], {
                            icon: L.divIcon({
                                className: 'poly-label',
                                html: `<div style="background:white; border-radius:50%; width:30px; height:30px; text-align:center; line-height:30px; color:black; font-size:10px; opacity: 0.8; font-weight:bold; pointer-events: auto;">${initialPercent}%</div>`,
                                iconSize: [30, 30],
                                iconAnchor: [15 - offsetX, 15 - offsetY] // Offset to position on circle edge
                            }),
                            interactive: true
                        }).addTo(targetLayer);
                    }

                    // LABEL UID Creation and setup (ONLY if label was created - i.e., not completed)
                    if (pLabel) {
                        // Use polygon UID to create deterministic white circle UID (prevents duplication on expand)
                        const whiteCircleUid = `WHITE_CIRCLE_${poly.uid.replace('POLYGON_', '')}`;
                        pLabel.uid = whiteCircleUid; // EXPLICITLY TRACK UID ON MARKER

                        const labelDebugData = {
                            uid: whiteCircleUid,
                            parent_polygon_uid: poly.uid,
                            boundary_white_lines: poly.boundary_white_lines,
                            center: poly.center,
                            label_direction: direction,  // Direction info
                            label_angle_degrees: direction.angle ? (direction.angle * 180 / Math.PI) : 0,
                            coords: poly.coords,
                            total_points: poly.total_points,
                            blue_circles_count: poly.blue_circles_count || 0,
                            merge_count: poly.merge_count || 1,
                            poster_ids: poly.poster_ids || [],
                            // Neighbor polygon data
                            neighbor_polygon_ids: poly.neighbor_polygon_ids || [],
                            neighbor_polygons_count: poly.neighbor_polygons_count || 0,
                            missing_polygons: poly.missing_polygons || 0
                        };
                        window.allItems.set(labelDebugData.uid, labelDebugData);

                        // Link Label to Polygon for Debug Highlighting
                        pLabel.visualSibling = pLayer;

                        // POLYFILL: Add setStyle to Marker (DivIcon) to support Debug Highlighting
                        pLabel.setStyle = function (style) {
                            const icon = this.options.icon;
                            let html = icon.options.html;

                            // Parse Style request
                            if (style.color === 'red') {
                                // Add Border
                                if (!html.includes('border: 3px solid red')) {
                                    // Add border to the inner div.
                                    // Note: The inner div has existing style. We append.
                                    // Box-sizing is border-box, so adding border won't break layout.
                                    html = html.replace('background:white;', 'background:white; border: 3px solid red;');
                                }
                            } else {
                                // Restore / Remove Border
                                html = html.replace('border: 3px solid red;', '');
                            }

                            // Update Icon
                            if (html !== icon.options.html) {
                                icon.options.html = html;
                                this.setIcon(icon);
                            }
                        };

                        // Attach debug click to the Label as well (shows Label + Polygon Data)
                        attachDebugClick(pLabel, labelDebugData, 'Polygon Label');
                    }

                    // Setup Promo Debug Data if exists
                    if (pPromo) {
                        // Use polygon UID to create deterministic large white circle UID
                        const largeWhiteCircleUid = `LARGE_WHITE_CIRCLE_${poly.uid.replace('POLYGON_', '')}`;
                        const promoDebugData = {
                            uid: largeWhiteCircleUid,
                            parent_polygon_uid: poly.uid,
                            gif: gifFile,
                            // Inherit polygon stats for context
                            neighbor_polygons_count: poly.neighbor_polygons_count
                        };
                        window.allItems.set(promoDebugData.uid, promoDebugData);
                        attachDebugClick(pPromo, promoDebugData, 'Promo Circle');
                    }

                    // Debug Bounding Box - must tightly wrap both circles
                    // Calculate bounding box that touches the extremes of both circles
                    // Large circle: center at (0,0), radius 30px
                    // Small circle: center at (offsetX, offsetY), radius 15px

                    // Find the extremes in all 4 directions from the large circle's center
                    const smallCenterX = offsetX;
                    const smallCenterY = offsetY;

                    // Calculate bounds
                    const maxX = Math.max(30, smallCenterX + 15); // Right edge
                    const minX = Math.min(-30, smallCenterX - 15); // Left edge
                    const maxY = Math.max(30, smallCenterY + 15); // Bottom edge
                    const minY = Math.min(-30, smallCenterY - 15); // Top edge

                    const boxWidth = maxX - minX;
                    const boxHeight = maxY - minY;

                    // iconAnchor should be offset from top-left corner to reach the large circle center
                    const anchorX = -minX;
                    const anchorY = -minY;

                    const pDebugBox = L.marker([centerPos[0], centerPos[1]], {
                        icon: L.divIcon({
                            className: 'debug-boundary-box',
                            html: '',
                            iconSize: [boxWidth, boxHeight],
                            iconAnchor: [anchorX, anchorY]
                        }),
                        interactive: false
                    }).addTo(targetLayer);

                    // savedCount already computed above (line ~2112)

                    const pState = {
                        id: poly.id, // Now uses RANDOM UID
                        uid: poly.uid,
                        coords: poly.coords, // Save coords for masking
                        current: savedCount, // Will usually be 0 unless random check luck
                        total: poly.total_points,
                        layer: pLayer,
                        label: pLabel,
                        promo: pPromo, // Track promo for removal
                        debugBox: pDebugBox, // NEW: Track debug box
                        lines: poly.boundary_white_lines // New UIDs
                    };


                    polygonState.set(poly.id, pState);

                    // Immediate Completion Check (Restoration)
                    // Immediate Completion Check (Restoration)
                    if (pState.current >= pState.total) {
                        console.log(`DEBUG: Restoring Completed Polygon ${poly.id} to Persistent Layer`);
                        // Move to Persistent Layer immediately
                        if (detailsLayer.hasLayer(pLayer)) detailsLayer.removeLayer(pLayer);
                        completedPolygonsLayer.addLayer(pLayer);

                        pLayer.setStyle({
                            color: 'transparent',
                            fillColor: 'transparent',
                            fillOpacity: 0,
                            stroke: false
                        });
                        // Remove label from detailsLayer explicitly
                        if (pLabel && detailsLayer.hasLayer(pLabel)) {
                            detailsLayer.removeLayer(pLabel);
                        }
                        // Remove promo from detailsLayer explicitly
                        if (pPromo && detailsLayer.hasLayer(pPromo)) {
                            detailsLayer.removeLayer(pPromo);
                        }
                        pState.label = null;
                        pState.promo = null;
                        pState.label = null;

                        // Reveal poster part
                        revealPolygonPart(pState.coords);

                        // Hide lines (Deferred until lines are created? No, lines created later. 
                        // Wait, lines are created AFTER polygons in this loop order?
                        // No, Polygons are step 2, White Lines are Step 3.
                        // We need to handle line hiding in Step 3 or a post-init check.)
                    }
                    else {
                        // Update Label Text if partially complete
                        const pct = Math.floor((pState.current / pState.total) * 100);
                        const icon = pLabel.options.icon;
                        icon.options.html = icon.options.html.replace(/>\d+%</, `>${pct}%<`);
                        pLabel.setIcon(icon);
                    }
                });

                // Restore poster masks for completed polygons (after all polygons initialized)
                // This ensures that when loading from cache, completed polygons show their posters
                console.log("DEBUG: Checking for completed polygons to restore poster masks...");
                let restoredMasksCount = 0;
                polygonState.forEach(state => {
                    if (state.current >= state.total && state.coords) {
                        console.log(`DEBUG: Restoring poster mask for completed polygon ${state.id}`);
                        revealPolygonPart(state.coords);
                        restoredMasksCount++;
                    }
                });
                console.log(`DEBUG: Restored ${restoredMasksCount} poster masks for completed polygons`);

                // 3. White Lines (Index)
                if (localWhiteLines && localWhiteLines.length > 0) {
                    controls.setSnapLines(localWhiteLines);
                    localWhiteLines.forEach(line => {
                        // Skip if line already exists (prevent duplication in expand mode)
                        if (lineLayerMap.has(String(line.id))) {
                            console.log(`DEBUG: White line ${line.id} already exists, skipping creation`);
                            return;
                        }

                        // Visual Layer (Thin, Dashed, Non-Interactive)
                        const visual = L.polyline(line.path, {
                            color: 'white', weight: 2, dashArray: '5, 5', interactive: false,
                            pane: 'blueCirclesPane'
                        }).addTo(targetLayer);

                        // Hit Layer (Thick, Solid, Transparent, Interactive)
                        const hit = L.polyline(line.path, {
                            color: 'white', weight: 15, opacity: 0, interactive: true,
                            pane: 'blueCirclesPane'
                        }).addTo(targetLayer);

                        attachDebugClick(hit, line, 'White Line');

                        // Composite Proxy for Logic Handling
                        const composite = {
                            visual: visual,
                            hit: hit,
                            setStyle: function (style) {
                                this.visual.setStyle(style);
                                // If hiding, disable hit layer interaction
                                if (style.opacity === 0) {
                                    this.hit.setStyle({ interactive: false });
                                } else {
                                    // Restore if showing
                                    this.hit.setStyle({ interactive: true });
                                }
                            }
                        };

                        if (line.id !== undefined) {
                            lineLayerMap.set(String(line.id), composite);
                        }
                    });
                    const currentPos = userMarker.getLatLng();
                    updateAndSaveUserPosition(userMarker, currentPos.lat, currentPos.lng, isGpsActive);

                    // POST-INIT: Hide lines for restored completed polygons
                    // DISABLE HIDING per user request (Keep white lines visible)
                    /*
                    polygonState.forEach(state => {
                        if (state.current >= state.total && state.lines) {
                            state.lines.forEach(lid => {
                                const lineLayer = lineLayerMap.get(String(lid));
                                if (lineLayer) {
                                    lineLayer.setStyle({ opacity: 0, fillOpacity: 0 });
                                }
                            });
                        }
                    });
                    */
                }

                // 4. Circles (Rendering + Mapping)
                // Track Layers for Hiding Logic
                // Note: circleLayerMap, blueCircleLayerMap, lineLayerMap, greenCirclesByLine are now global (defined at top)

                const addToMap = (lat, lon, layer, type, lineId = -1) => {
                    const key = `${lat.toFixed(6)},${lon.toFixed(6)}`;
                    circleLayerMap.set(key, layer);

                    // Map to Polygons
                    mapCircleToPolys(lat, lon, localPolys, lineId);
                };

                // Shared Debug Click Handler (Removed from here, moved to top)


                if (localBlueCircles && localBlueCircles.length > 0) {
                    localBlueCircles.forEach(circle => {
                        // Check immediate collection state to prevent flicker
                        const key = `${circle.lat.toFixed(6)},${circle.lon.toFixed(6)}`;

                        // Skip if already rendered (expand mode reuses existing circles)
                        if (circleLayerMap.has(key)) {
                            // Circle already exists, update its data in window.allItems
                            for (const [uid, item] of window.allItems.entries()) {
                                if (item.lat !== undefined && item.lon !== undefined) {
                                    const itemKey = `${item.lat.toFixed(6)},${item.lon.toFixed(6)}`;
                                    if (itemKey === key && uid.startsWith('BLUE_CIRCLE_')) {
                                        // Merge new polygon IDs with existing ones (don't duplicate)
                                        const existingIds = new Set(item.connected_polygon_ids || []);
                                        (circle.connected_polygon_ids || []).forEach(pid => existingIds.add(pid));
                                        item.connected_polygon_ids = Array.from(existingIds);
                                        item.connected_polygons_count = item.connected_polygon_ids.length;

                                        // UPDATE STATS: Start by overwriting with new stats from backend
                                        // The backend sends fresh stats for this node in the expansion response.
                                        item.stats_connected_lines = circle.stats_connected_lines;
                                        item.stats_not_connected_lines = circle.stats_not_connected_lines;
                                        item.active_connections = circle.active_connections; // Ensure this is updated too
                                        item.is_saturated = circle.is_saturated; // Crucial for visuals

                                        // RECALCULATE Polygon Stats based on Merged Data (Global View)
                                        // Backend only sees local polygons in the expansion region.
                                        // Frontend has the full history.
                                        item.stats_connected_polygons = item.connected_polygon_ids.length;

                                        // Precise Logic: Missing = Connected Lines (Total/Expected) - Found Polygons
                                        // This allows mismatch (e.g. Lines=3, Found=2, Missing=1)
                                        const expectedPolygons = item.stats_connected_lines;
                                        item.stats_not_connected_polygons = Math.max(0, expectedPolygons - item.stats_connected_polygons);

                                        // Update visual marker state if needed (e.g. saturation color)
                                        // Strict Saturation: Must have 0 Missing Polygons AND 0 Missing Lines.
                                        const isNowSaturated = (item.stats_not_connected_polygons === 0) && (item.stats_not_connected_lines === 0) && (item.stats_connected_lines > 0);
                                        item.is_saturated = isNowSaturated;

                                        const existingMarker = circleLayerMap.get(key);
                                        if (existingMarker) {
                                            existingMarker.isSaturated = isNowSaturated;
                                            if (isNowSaturated) {
                                                existingMarker.setStyle({ color: '#ff7b00', fillColor: '#ffa600' });
                                            } else {
                                                // REVERT TO BLUE if no longer saturated!
                                                existingMarker.setStyle({ color: 'blue', fillColor: '#00ccff' });
                                            }
                                        }
                                        break;
                                    }
                                }
                            }
                            // Update polygon mapping
                            mapCircleToPolys(circle.lat, circle.lon, localPolys, -1);
                            return; // Skip rendering
                        }

                        // Saturated (Orange) vs Normal (Blue)
                        const isSaturated = circle.is_saturated || false;
                        const mainColor = isSaturated ? '#ff7b00' : 'blue';       // Orange vs Blue
                        const fillColor = isSaturated ? '#ffa600' : '#00ccff';    // Light Orange vs Light Blue

                        const isCollected = collectedCircles.has(key);

                        // Track expanded circle coordinates
                        if (mode === 'expand') {
                            expandedCircleCoords.add(key);
                        }

                        const marker = L.circleMarker([circle.lat, circle.lon], {
                            radius: 8,
                            color: mainColor,
                            fillColor: fillColor,
                            fillOpacity: isCollected && !isPostersDebugActive ? 0 : 0.8,
                            opacity: isCollected && !isPostersDebugActive ? 0 : 1, // Start hidden if collected!
                            interactive: !isCollected, // Disable interaction if collected
                            pane: 'blueCirclesPane' // Render in dedicated pane above white lines
                        }).addTo(targetLayer);

                        // If collected but debug active, style accordingly
                        if (isCollected && isPostersDebugActive) {
                            marker.setStyle({ color: '#555', opacity: 0.5 });
                        }

                        // Save connection count for debug restoration
                        marker.connections = circle.connections;
                        marker.isSaturated = isSaturated; // EXPOSE FOR LOGIC

                        // UID Logic & Persistence
                        const blueUid = circle.id || `BLUE_CIRCLE_${circle.lat.toFixed(6)}_${circle.lon.toFixed(6)}`;
                        marker.uid = blueUid;

                        // Ensure data is in window.allItems for persistence (Critical for saveGlobalState)
                        if (window.allItems) {
                            window.allItems.set(blueUid, {
                                ...circle,
                                id: blueUid,
                                uid: blueUid // Unified key
                            });
                        }

                        if (!isCollected) {
                            marker.bindTooltip(String(circle.connections), { permanent: true, direction: 'center', className: 'circle-label' });
                        }

                        // Blue circles are large enough, no composite needed yet unless requested
                        addToMap(circle.lat, circle.lon, marker, 'blue');
                        attachDebugClick(marker, circle, 'Blue Circle');

                        // Track for polygon debug highlighting
                        const coordKey = `${circle.lat.toFixed(6)},${circle.lon.toFixed(6)}`;
                        blueCircleLayerMap.set(coordKey, marker);
                    });
                }

                // --- NEIGHBOR PROPAGATION: Update relevant Blue Circles even if not in response ---
                // Expansion sends New Polygons and their "Focus" Blue Circles. All neighboring Blue Circles sharing a White Line
                // with the new Polygon must also be updated to know about the new Polygon.
                if (localPolys && localPolys.length > 0) {
                    localPolys.forEach(poly => {
                        const polyId = poly.id;
                        (poly.boundary_white_lines || []).forEach(lineId => {
                            // Find the white line to get its endpoints
                            // We don't have a direct map of Line ID -> Objects easily accessible in scope unless we search.
                            // But we can search localWhiteLines first, then global active lines?
                            // Optimization: Iterate window.allItems to find lines? No, too slow.

                            // Better: In backend, 'white_lines' response includes ALL lines of the new polygons?
                            // Yes, 'expand' usually sends the white lines of the new polygons.
                            // Let's assume the line is in 'localWhiteLines'.

                            let whiteLine = null;
                            if (localWhiteLines) whiteLine = localWhiteLines.find(l => l.id === lineId);

                            // Optimization: Check global items directly by ID (Keys are UIDs)
                            if (!whiteLine && window.allItems) {
                                whiteLine = window.allItems.get(lineId);
                            }

                            if (whiteLine && whiteLine.endpoint_blue_circles) {
                                whiteLine.endpoint_blue_circles.forEach(bcUid => {
                                    // Find this Blue Circle in global items to update it
                                    if (window.allItems && window.allItems.has(bcUid)) {
                                        const bcItem = window.allItems.get(bcUid);

                                        // Update Connected Polygons
                                        const existingIds = new Set(bcItem.connected_polygon_ids || []);
                                        existingIds.add(polyId);
                                        bcItem.connected_polygon_ids = Array.from(existingIds);
                                        bcItem.connected_polygons_count = bcItem.connected_polygon_ids.length;

                                        // RECALCULATE Stats (Local Calculation)
                                        // 1. Recalculate Connected Lines (Visible)
                                        // We must ensure the 'Total Lines' count increases if a new line became visible.
                                        if (bcItem.connected_white_lines) {
                                            let visibleLinesCount = 0;
                                            bcItem.connected_white_lines.forEach(lid => {
                                                // Check if line is visible (in global items or local new items)
                                                let isVisible = false;
                                                if (window.allItems && window.allItems.has(lid)) isVisible = true;
                                                if (!isVisible && localWhiteLines) {
                                                    if (localWhiteLines.find(l => l.id === lid)) isVisible = true;
                                                }
                                                if (isVisible) visibleLinesCount++;
                                            });
                                            bcItem.stats_connected_lines = visibleLinesCount;
                                        }

                                        // 2. Recalculate Connected Polygons (Visible)
                                        // Precise Logic: Missing = Connected Lines - Found Polygons
                                        bcItem.stats_connected_polygons = bcItem.connected_polygon_ids.length;

                                        const expectedPolygons = bcItem.stats_connected_lines || bcItem.connections || 0;
                                        bcItem.stats_not_connected_polygons = Math.max(0, expectedPolygons - bcItem.stats_connected_polygons);

                                        // Update Saturation
                                        // Strict Saturation: Must have 0 Missing Polygons AND 0 Missing Lines.
                                        const isNowSaturated = (bcItem.stats_not_connected_polygons === 0) && (bcItem.stats_not_connected_lines === 0) && (bcItem.stats_connected_lines > 0);
                                        bcItem.is_saturated = isNowSaturated;

                                        // Update Visuals
                                        const key = `${bcItem.lat.toFixed(6)},${bcItem.lon.toFixed(6)}`;
                                        const marker = circleLayerMap.get(key);
                                        if (marker) {
                                            marker.isSaturated = isNowSaturated;
                                            if (isNowSaturated) {
                                                marker.setStyle({ color: '#ff7b00', fillColor: '#ffa600' });
                                            } else {
                                                // REVERT TO BLUE if no longer saturated!
                                                marker.setStyle({ color: 'blue', fillColor: '#00ccff' });
                                            }
                                        }
                                    }
                                });
                            }
                        });
                    });
                }



                // --- FINAL SAFETY CHECK: Verification of ALL Blue Circles ---
                // "Is there another method to check?" -> Yes, checking EVERYTHING.
                // RECONSTRUCTION MODE: We don't just validate, we REBUILD the Blue Circle data from the White Lines.
                // This ensures that the Blue Circle's view of the world matches the Graph's reality.
                if (mode === 'expand' && window.allItems) {

                    // 1. Prepare: Clear/Init stats for reconstruction?
                    // Actually, safer to just Accumulate correct data, then Deduplicate.
                    // We need to map [WhiteLine -> Polygons] and [WhiteLine -> BlueCircles]

                    // Let's iterate ALL White Lines (Global + Local if merged)
                    const relevantBlueCircles = new Set();

                    window.allItems.forEach(item => {
                        // Identify White Lines
                        if (item.id && item.id.startsWith('WHITE_LINE_')) {
                            // Valid White Line.
                            const lineUid = item.id;
                            const linePolys = item.connected_polygon_ids || [];

                            // Propagate to Blue Circle Endpoints
                            if (item.endpoint_blue_circles) {
                                item.endpoint_blue_circles.forEach(bcUid => {
                                    if (window.allItems.has(bcUid)) {
                                        const bcItem = window.allItems.get(bcUid);
                                        relevantBlueCircles.add(bcItem);

                                        // A. Ensure this White Line UID is in the Blue Circle's list
                                        // (Handling the Raw ID mismatch issue automatically by pushing UID)
                                        if (!bcItem.connected_white_lines_uids) bcItem.connected_white_lines_uids = new Set();
                                        bcItem.connected_white_lines_uids.add(lineUid);

                                        // B. Ensure all Polygons of this Line are in the Blue Circle's list
                                        if (!bcItem.connected_polygon_ids_set) bcItem.connected_polygon_ids_set = new Set(bcItem.connected_polygon_ids || []);
                                        linePolys.forEach(pid => {
                                            if (window.allItems.has(pid)) { // Only add if Polygon actually exists
                                                bcItem.connected_polygon_ids_set.add(pid);
                                            }
                                        });
                                    }
                                });
                            }
                        }
                    });

                    // 2. Finalize & Recalculate for all touched Blue Circles
                    // (Or just all Blue Circles to be safe? Let's do all items that look like Blue Circles)
                    window.allItems.forEach(item => {
                        if (item.id && item.id.startsWith('BLUE_CIRCLE_')) {
                            // Flush Sets to Lists if we used them, or validate existing if we didn't touch them
                            if (item.connected_white_lines_uids) {
                                // We have reconstructed UIDs! Use them for count.
                                item.stats_connected_lines = item.connected_white_lines_uids.size;
                                // Optional: sync back to array if needed for debugging
                                // item.connected_white_lines = Array.from(item.connected_white_lines_uids); 
                            } else {
                                // Fallback: If we didn't find any white lines connecting to it via traversal,
                                // maybe it's isolated or data is weird.
                                // But we should verify validity of what it holds.
                                if (item.connected_white_lines) {
                                    let visibleCount = 0;
                                    item.connected_white_lines.forEach(lid => {
                                        if (window.allItems.has(lid)) visibleCount++;
                                    });
                                    item.stats_connected_lines = visibleCount;
                                }
                            }

                            if (item.connected_polygon_ids_set) {
                                item.connected_polygon_ids = Array.from(item.connected_polygon_ids_set);
                            } else if (item.connected_polygon_ids) {
                                // Filter ghosts
                                item.connected_polygon_ids = item.connected_polygon_ids.filter(pid => window.allItems.has(pid));
                            }
                            item.stats_connected_polygons = item.connected_polygon_ids ? item.connected_polygon_ids.length : 0;

                            // 3. Recalculate Stats & Saturation
                            const expectedPolygons = item.stats_connected_lines || item.connections || 0;
                            item.stats_not_connected_polygons = Math.max(0, expectedPolygons - item.stats_connected_polygons);
                            item.stats_not_connected_lines = Math.max(0, (item.connections || 0) - (item.stats_connected_lines || 0));

                            // Strict Saturation Check
                            const isNowSaturated = (item.stats_not_connected_polygons === 0) && (item.stats_not_connected_lines === 0) && (item.stats_connected_lines > 0);
                            item.is_saturated = isNowSaturated;

                            // 4. Update Visuals
                            const key = `${item.lat.toFixed(6)},${item.lon.toFixed(6)}`;
                            const marker = circleLayerMap.get(key);
                            if (marker) {
                                marker.isSaturated = isNowSaturated;
                                if (marker.isSaturated) {
                                    marker.setStyle({ color: '#ff7b00', fillColor: '#ffa600' });
                                } else {
                                    marker.setStyle({ color: 'blue', fillColor: '#00ccff' });
                                }
                            }
                        }
                    });
                }

                if (localGreenCircles && localGreenCircles.length > 0) {
                    localGreenCircles.forEach(circle => {
                        // Check immediate collection state
                        const coordKey = `${circle.lat.toFixed(6)},${circle.lon.toFixed(6)}`;

                        // Skip if already rendered (expand mode reuses existing circles)
                        if (circleLayerMap.has(coordKey)) {
                            // Circle already exists, just update polygon mapping
                            mapCircleToPolys(circle.lat, circle.lon, localPolys, circle.line_id || -1);

                            // Also ensure it's in greenCirclesByLine map (for hide on completion)
                            if (circle.line_id !== undefined) {
                                const existingLayer = circleLayerMap.get(coordKey);
                                if (existingLayer && existingLayer.visual) {
                                    if (!greenCirclesByLine.has(circle.line_id)) {
                                        greenCirclesByLine.set(circle.line_id, []);
                                    }
                                    // Check if not already in array to avoid duplicates
                                    const circles = greenCirclesByLine.get(circle.line_id);
                                    if (!circles.includes(existingLayer.visual)) {
                                        circles.push(existingLayer.visual);
                                    }
                                }
                            }
                            return; // Skip rendering
                        }

                        const isCollected = collectedCircles.has(coordKey);

                        // Track expanded circle coordinates
                        if (mode === 'expand') {
                            expandedCircleCoords.add(coordKey);
                        }

                        // Visual (Small)
                        const visual = L.circleMarker([circle.lat, circle.lon], {
                            radius: 4,
                            color: 'green',
                            fillColor: '#00ff00',
                            fillOpacity: isCollected && !isPostersDebugActive ? 0 : 1,
                            opacity: isCollected && !isPostersDebugActive ? 0 : 1,
                            interactive: false,
                            pane: 'blueCirclesPane'
                        }).addTo(targetLayer);

                        // If collected but debug, style
                        if (isCollected && isPostersDebugActive) {
                            visual.setStyle({ color: '#555', opacity: 0.5 });
                        }

                        // Hit (Large)
                        const hit = L.circleMarker([circle.lat, circle.lon], {
                            radius: 12, stroke: false, fillOpacity: 0,
                            interactive: !isCollected, // Disable hit if collected
                            pane: 'blueCirclesPane'
                        }).addTo(targetLayer);

                        hit.visualSibling = visual; // Helper for Debug Highlighting

                        attachDebugClick(hit, circle, 'Green Circle');

                        // Composite Proxy
                        const composite = {
                            visual: visual,
                            hit: hit,
                            get options() { return this.visual.options; }, // Dynamic Getter to ensure live state Check
                            setStyle: function (style) {
                                this.visual.setStyle(style);
                                // If hiding, disable hit layer
                                if (style.opacity === 0) {
                                    this.hit.setStyle({ interactive: false });
                                } else {
                                    this.hit.setStyle({ interactive: true });
                                }
                            },
                            getTooltip: function () { return this.visual.getTooltip(); }, // Pass through (Fix Context)
                            unbindTooltip: function () { return this.visual.unbindTooltip(); }
                        };

                        addToMap(circle.lat, circle.lon, composite, 'green', circle.line_id);

                        // Track for polygon debug highlighting (by line_id)
                        if (circle.line_id !== undefined) {
                            if (!greenCirclesByLine.has(circle.line_id)) {
                                greenCirclesByLine.set(circle.line_id, []);
                            }
                            greenCirclesByLine.get(circle.line_id).push(visual);
                        }
                    });
                }

                // STEP 1: Update connected_polygon_ids for ALL existing blue circles with new polygon UIDs
                if (mode === 'expand') {
                    // Create a map of white line endpoints to polygon UIDs from localPolys
                    const endpointToPolyIds = new Map();
                    localPolys.forEach(poly => {
                        const whiteLines = poly.whiteLines || [];
                        whiteLines.forEach(line => {
                            // Add start point
                            const startKey = `${line.start[0].toFixed(6)},${line.start[1].toFixed(6)}`;
                            if (!endpointToPolyIds.has(startKey)) {
                                endpointToPolyIds.set(startKey, new Set());
                            }
                            endpointToPolyIds.get(startKey).add(poly.id);

                            // Add end point
                            const endKey = `${line.end[0].toFixed(6)},${line.end[1].toFixed(6)}`;
                            if (!endpointToPolyIds.has(endKey)) {
                                endpointToPolyIds.set(endKey, new Set());
                            }
                            endpointToPolyIds.get(endKey).add(poly.id);
                        });
                    });

                    // Update ALL blue circles with new polygon IDs
                    blueCircleLayerMap.forEach((layer, coordKey) => {
                        // Get circle data from window.allItems
                        let circleData = null;
                        for (const [uid, item] of window.allItems.entries()) {
                            if (item.lat !== undefined && item.lon !== undefined) {
                                const itemKey = `${item.lat.toFixed(6)},${item.lon.toFixed(6)}`;
                                if (itemKey === coordKey && uid.startsWith('BLUE_CIRCLE_')) {
                                    circleData = item;
                                    break;
                                }
                            }
                        }

                        if (circleData) {
                            // Check if this circle is an endpoint of any new polygons
                            const newPolyIds = endpointToPolyIds.get(coordKey);
                            if (newPolyIds && newPolyIds.size > 0) {
                                // Merge new polygon IDs with existing ones
                                const existingIds = new Set(circleData.connected_polygon_ids || []);
                                newPolyIds.forEach(pid => existingIds.add(pid));
                                circleData.connected_polygon_ids = Array.from(existingIds);

                                console.log(`DEBUG: Updated circle ${coordKey}: added ${newPolyIds.size} new polygon IDs, total now: ${circleData.connected_polygon_ids.length}`);
                            }
                        }
                    });
                }

                // STEP 2: Recalculate is_saturated for ALL blue circles based on updated connected_polygon_ids
                if (mode === 'expand') {
                    // Iterate through ALL circles in blueCircleLayerMap (not just new ones from data.blue_circles)
                    blueCircleLayerMap.forEach((layer, coordKey) => {
                        // Get circle data from window.allItems
                        let circleData = null;
                        for (const [uid, item] of window.allItems.entries()) {
                            if (item.lat !== undefined && item.lon !== undefined) {
                                const itemKey = `${item.lat.toFixed(6)},${item.lon.toFixed(6)}`;
                                if (itemKey === coordKey && uid.startsWith('BLUE_CIRCLE_')) {
                                    circleData = item;
                                    break;
                                }
                            }
                        }

                        if (circleData && circleData.connected_polygon_ids) {
                            // Count how many of this circle's polygons are currently visible
                            const visiblePolyCount = circleData.connected_polygon_ids.filter(pid => visiblePolygonIds.has(pid)).length;
                            const totalConnections = circleData.connections || 0;

                            // Circle is saturated (orange) if ALL its connections are to visible polygons
                            const shouldBeSaturated = (totalConnections === visiblePolyCount && totalConnections > 0);

                            // Update visual if saturation state changed
                            if (shouldBeSaturated !== circleData.is_saturated) {
                                circleData.is_saturated = shouldBeSaturated;
                                layer.isSaturated = shouldBeSaturated;

                                const newMainColor = shouldBeSaturated ? '#ff7b00' : 'blue';
                                const newFillColor = shouldBeSaturated ? '#ffa600' : '#00ccff';
                                layer.setStyle({ color: newMainColor, fillColor: newFillColor });

                                console.log(`DEBUG: Updated circle at ${coordKey}: connections=${totalConnections}, visible_polys=${visiblePolyCount}, is_saturated=${shouldBeSaturated}`);
                            }
                        }
                    });
                }

                // Set debug maps for polygon highlighting feature
                setDebugMaps(lineLayerMap, circleLayerMap, blueCircleLayerMap, greenCirclesByLine, polygonState);

                // Red Lines / Street Names removed. 
                // We now use the Google Text Overlay in map_controls.js

                // Setup Hiding Logic with Progress Tracking
                controls.checkVisibility();
                const currentZoom = map.getZoom();
                console.log(`GPS: Visibility check complete. Current zoom: ${currentZoom}. detailsLayer has ${detailsLayer.getLayers().length} layers.`);
                console.log(`GPS: Polygons visible at zoom >= 18. Current: ${currentZoom >= 18 ? 'YES' : 'NO'}`);

                // --- SNAP LOGIC EXPORT & INITIAL SNAP ---
                // Defined BEFORE setupProgressHiding so it can be used immediately
                window.findNearestActiveCircle = (userLat, userLon) => {
                    let nearest = null;
                    let minDist = Infinity;
                    const SNAP_DIST_DEG = 0.001; // Increased to ~100 meters

                    circleLayerMap.forEach((layer, key) => {
                        const [cLat, cLon] = key.split(',').map(Number);
                        const dist = Math.sqrt(Math.pow(cLat - userLat, 2) + Math.pow(cLon - userLon, 2));

                        if (dist < SNAP_DIST_DEG) {
                            // console.log(`DEBUG: Candidate circle at ${cLat},${cLon} dist: ${dist}`);
                            if (dist < minDist) {
                                minDist = dist;
                                nearest = { lat: cLat, lon: cLon, dist: dist, key: key };
                            }
                        }
                    });

                    if (nearest) {
                        console.log(`DEBUG: Found Nearest Circle: ${nearest.lat},${nearest.lon} (Dist: ${nearest.dist})`);
                    } else {
                        console.log(`DEBUG: No circle found within ${SNAP_DIST_DEG} degrees.`);
                    }

                    return nearest;
                };

                // INITIAL SNAP CHECK
                // If we have a saved user position, restore it directly (even if circle not visible)
                // Otherwise, snap to nearest active circle
                if (currentUserPosition && currentUserPosition.lat !== undefined && mode === 'initial') {
                    console.log(`DEBUG: Restoring saved user position: ${currentUserPosition.lat}, ${currentUserPosition.lon}`);
                    userMarker.setLatLng([currentUserPosition.lat, currentUserPosition.lon]);
                    updateAndSaveUserPosition(userMarker, currentUserPosition.lat, currentUserPosition.lon, false);
                }

                // ALWAYS snap to nearest active circle on initial load (force centering)
                // This ensures the "collection" logic triggers correctly
                if (mode === 'initial') {
                    console.log(`DEBUG: Mode is 'initial' - SNAP logic will execute`);
                    const currentPos = userMarker.getLatLng();
                    const initialSnap = window.findNearestActiveCircle(currentPos.lat, currentPos.lng);
                    if (initialSnap) {
                        console.log(`DEBUG: Initial Snap triggered! Moving from ${currentPos.lat},${currentPos.lng} to ${initialSnap.lat},${initialSnap.lon}`);
                        // Move marker directly
                        userMarker.setLatLng([initialSnap.lat, initialSnap.lon]);
                        updateAndSaveUserPosition(userMarker, initialSnap.lat, initialSnap.lon, (isGpsActive && window.loadedQuality !== 'NONE'));
                    }
                } else if (mode === 'restore') {
                    // Debug logging to confirm SNAP is skipped during restoration
                    console.log(`DEBUG: Mode is 'restore' - SNAP logic SKIPPED (marker should be at saved position)`);
                    const currentPos = userMarker.getLatLng();
                    console.log(`DEBUG: Current marker position after restore: ${currentPos.lat}, ${currentPos.lng}`);
                }

                controls.updateGraph(localGreenCircles, localBlueCircles, localWhiteLines);
                // setupProgressHiding moved to after state application

                // --- STATE APPLICATION LOGIC ---
                // Helper to apply a set of collected keys to the map state
                const applyCollectedState = (keysToApply) => {
                    if (!keysToApply || keysToApply.size === 0) return;

                    console.log(`DEBUG: Applying ${keysToApply.size} collected circles to state...`);
                    let appliedCount = 0;

                    keysToApply.forEach(key => {
                        const target = circleLayerMap.get(key);

                        // Ensure it's in our memory tracking
                        collectedCircles.add(key);

                        if (target) {
                            // Check visibility rules
                            const shouldHide = !isPostersDebugActive;
                            if (shouldHide && target.options.opacity !== 0) {
                                target.setStyle({ opacity: 0, fillOpacity: 0 });
                            }
                            if (typeof target.getTooltip === 'function' && target.getTooltip()) {
                                target.unbindTooltip();
                            }
                            // Update visual for hit box too if composite
                            if (target.visualSibling) {
                                if (shouldHide) target.visualSibling.setStyle({ opacity: 0, fillOpacity: 0 });
                            }

                            // Update visual progress maps
                            const relevantPolys = circleToPolyMap.get(key);
                            if (relevantPolys) {
                                relevantPolys.forEach(pid => {
                                    const state = polygonState.get(pid);
                                    if (state) state.current++; // Increment local count
                                });
                            }
                            appliedCount++;
                        }
                    });

                    // Recalculate Polygon Completion & Visuals
                    let completedAndMasked = 0;
                    polygonState.forEach(state => {
                        updatePolygonVisuals(state, lineLayerMap);
                        if (state.current >= state.total && state.coords) {
                            completedAndMasked++;
                        }
                    });

                    console.log(`DEBUG: Applied state. Completed polygons: ${completedAndMasked}`);

                    // FORCE MASK UPDATE NOW (Synchronous)
                    updateMaskPaths();
                };

                // 1. SYNC APPLY: Apply what we already have in memory (Important for Expansion!)
                // Reset polygon counts first (globally for this render)
                // We'll recalculate from scratch based on collectedCircles
                polygonState.forEach(state => state.current = 0);

                if (collectedCircles.size > 0) {
                    console.log(`DEBUG: Sync applying ${collectedCircles.size} memory-cached circles...`);
                    applyCollectedState(collectedCircles);
                } else {
                    // Even if empty, update mask (it might be empty)
                    updateMaskPaths();
                }

                // MOVED FROM ABOVE: Setup hiding logic (and run initial check)
                // We do this AFTER state application so that the initial check (which might collect a new circle)
                // adds to the already-restored count, rather than being wiped by the reset loop.
                setupProgressHiding(circleLayerMap, circleToPolyMap, polygonState, lineLayerMap, blueCircleLayerMap);

                // 2. ASYNC FETCH: Fetch from server/localstorage to catch up anything missing
                fetchSavedCircles(currentLocationKey)
                    .then(savedKeys => {
                        console.log("DEBUG: Async restoration complete.");

                        // FILTER: Only apply keys that are NOT already in collectedCircles (memory)
                        // AND not in clearedCircleCoords (intentionally cleared in expand mode)
                        // This prevents double-counting progress since collectedCircles were already applied synchronously above.
                        const newKeys = new Set();
                        savedKeys.forEach(key => {
                            if (!collectedCircles.has(key) && !clearedCircleCoords.has(key)) {
                                newKeys.add(key);
                            }
                        });

                        if (newKeys.size > 0) {
                            console.log(`DEBUG: Applying ${newKeys.size} NEW keys found from server...`);
                            applyCollectedState(newKeys);
                        } else {
                            console.log("DEBUG: No new keys from server to apply.");
                        }
                    });


                map.on('viewreset move zoom', updateMaskPaths);

                // Initial mask update (Important for expansion mode when bounds change!)
                updateMaskPaths();

                // Update debug box intersections if debug mode is active
                if (isDebugActive) {
                    console.log('DEBUG: renderGameElements complete - updating debug box intersections');
                    updateDebugBoxIntersections();
                }

                // Save state after rendering (especially important for expand mode)
                if (mode === 'expand') {
                    console.log('DEBUG: Expand complete - saving state...');
                    await saveLocationState();
                }

                // Add layers to map AFTER all elements are loaded (synchronous rendering)
                if (!map.hasLayer(detailsLayer)) {
                    detailsLayer.addTo(map);
                    console.log('DEBUG: detailsLayer added to map - all elements rendered synchronously');
                }
                if (!map.hasLayer(expandedLayer)) {
                    expandedLayer.addTo(map);
                    console.log('DEBUG: expandedLayer added to map');
                }

                // Removed: initPosterGrid() call at end (already done at start)

                // Clear restoration flag - state is now fully restored
                if (isRestoringState) {
                    isRestoringState = false;
                    console.log(`DEBUG: 🔓 Setting isRestoringState = false (restoration complete, saves now allowed)`);
                }
            };

            // NEW: Helper to fetch saved circles from Redis (Pure Data Fetching)
            const fetchSavedCircles = async (locationKey) => {
                const combinedCircles = new Set();
                if (!locationKey) return combinedCircles;

                // Load from Server (Redis) - the authoritative source
                try {
                    const savedState = await loadLocationState(locationKey);
                    if (savedState && savedState.collected_circles && savedState.collected_circles.length > 0) {
                        savedState.collected_circles.forEach(k => combinedCircles.add(k));
                        console.log(`DEBUG: Loaded ${savedState.collected_circles.length} circles from Redis`);

                        // Restore expanded state
                        if (savedState.visible_polygon_ids && savedState.visible_polygon_ids.length > 0) {
                            savedState.visible_polygon_ids.forEach(id => visiblePolygonIds.add(id));
                            console.log(`DEBUG: Restored ${savedState.visible_polygon_ids.length} visible polygon IDs from Redis`);
                        }

                        if (savedState.expanded_circles && savedState.expanded_circles.length > 0) {
                            savedState.expanded_circles.forEach(coord => expandedCircles.add(coord));
                            console.log(`DEBUG: Restored ${savedState.expanded_circles.length} expanded circles from Redis`);
                        }
                    }
                } catch (e) {
                    console.warn("DEBUG: Failed to load circles from Redis:", e);
                }

                return combinedCircles;
            };


            // Restore previously collected circles from server AND LocalStorage
            // REFACTORED: Now accepts pure data or fetches if needed



            const setupProgressHiding = (layerMap, circleMap, polyState, lineMap, blueMap) => {
                const checkAndHide = () => {
                    const pos = userMarker.getLatLng();
                    const exactKey = `${pos.lat.toFixed(6)},${pos.lng.toFixed(6)}`;

                    console.log(`DEBUG: CheckAndHide checking pos: ${exactKey}`);

                    let target = layerMap.get(exactKey);

                    // Fallback: Fuzzy search if exact match misses (due to float drift or manual snap differences)
                    if (!target && window.findNearestActiveCircle) {
                        const nearest = window.findNearestActiveCircle(pos.lat, pos.lng);
                        // Strict threshold for "arrived" (e.g. < 10cm or just exact snap check with epsilon)
                        if (nearest && nearest.dist < 0.000001) {
                            const fuzzyKey = `${nearest.lat.toFixed(6)},${nearest.lon.toFixed(6)}`;
                            console.log(`DEBUG: Exact match failed, but found fuzzy match: ${fuzzyKey} (dist: ${nearest.dist})`);
                            target = layerMap.get(fuzzyKey);
                        }
                    }


                    let targetKey = null;

                    if (target) {
                        // GLOBAL STATE TRACKING: Update current circle UID
                        if (target.uid) {
                            if (currentCircleUid !== target.uid) {
                                console.log(`GLOBAL_STATE: Player moved to circle ${target.uid}`);
                                currentCircleUid = target.uid;

                                // Save state immediately when reaching a new circle
                                if (!isRestoringState) {
                                    saveGlobalState();
                                }
                            }
                        }

                        // Re-calculate targetKey (since target might be from fuzzy match)
                        targetKey = exactKey;
                        // If exact match failed, we need to recover the key from the target... 
                        // Actually, we can just re-run the logic or check if we have the key.
                        // Ideally we should have stored the found key. 

                        // Let's re-run the fuzzy logic to be safe and simple
                        if (target !== layerMap.get(exactKey) && window.findNearestActiveCircle) {
                            const nearest = window.findNearestActiveCircle(pos.lat, pos.lng);
                            if (nearest) targetKey = `${nearest.lat.toFixed(6)},${nearest.lon.toFixed(6)}`;
                        }

                        const isCollected = collectedCircles.has(targetKey);
                        if (!isCollected) {
                            console.log(`DEBUG: COLLECTED CIRCLE at ${exactKey}`);

                            // 1. Mark Collected
                            collectedCircles.add(targetKey);

                            // 2. Save to Redis (server) - no client-side storage
                            // Note: saveLocationState is called periodically and on key events
                            if (!isRestoringState) {
                                console.log(`DEBUG: Collected circle at ${targetKey}, will persist to Redis`);
                            }


                            // 3. Persist Server (Debounced/Throttled usually, but here immediate-ish)
                            // Note: frequent saves might spam server.
                            // Optimized: saveLocationState is simple fetch. 

                            // 4. Hide Visual (Unless Debug Posters Active)
                            if (!isPostersDebugActive) {
                                target.setStyle({ opacity: 0, fillOpacity: 0 });
                            } else {
                                target.setStyle({ color: '#555', opacity: 0.5 }); // Visual Feedback in Debug
                            }

                            // Safe Tooltip Check (Must be a function and truthy)
                            if (typeof target.getTooltip === 'function' && target.getTooltip()) {
                                target.unbindTooltip(); // Permanently remove label
                            }

                            // UPDATE PROGRESS
                            // We need the key to look up relevantPolys
                            const relevantPolys = circleMap.get(targetKey);
                            if (relevantPolys) {
                                relevantPolys.forEach(pid => {
                                    const state = polyState.get(pid);
                                    if (state && state.current < state.total) {
                                        state.current++;
                                        updatePolygonVisuals(state, lineMap);
                                    }
                                });
                            }
                        }
                    }

                    // MAP EXPANSION CHECK (Blue Circles)
                    // This runs for ANY move (GPS or Manual)
                    // We check if targetKey (exact or fuzzy) is a blue circle
                    let finalTargetKey = target ? `${userMarker.getLatLng().lat.toFixed(6)},${userMarker.getLatLng().lng.toFixed(6)}` : null;
                    if (target && target._latlng) {
                        // Use target's latlng for precision key reconstruction or rely on layerMap keys
                        // Actually targetKey variable is available in scope above.
                    }

                    // We use 'targetKey' variable from above scope.
                    // However, we need to ensure targetKey is valid even if !target (but we only care if target exists?)
                    // Actually, we care if we reached a blue circle. Blue circles are in layerMap.
                    // So if (target) is true, we found SOMETHING.

                    if (target && blueMap && blueMap.has(targetKey)) {
                        // Check if Saturated (Orange) - If so, NO EXPANSION
                        if (target.isSaturated) {
                            // console.log(`DEBUG: Reached Saturated Circle ${targetKey} -> No Expansion.`);
                        }
                        else if (!expandedCircles.has(targetKey)) {
                            console.log(`DEBUG: Reached new Blue Circle ${targetKey} -> Triggering Map Expansion...`);
                            expandedCircles.add(targetKey);

                            // State will be saved to Redis after expansion completes via saveLocationState()

                            const [latStr, lonStr] = targetKey.split(',');
                            loadGameData(parseFloat(latStr), parseFloat(lonStr), false, 'expand');
                        }

                    }

                    // Trigger debounced save after any movement (unless restoring state)
                    if (!isRestoringState && target) {
                        debouncedSavePosition();
                    }

                };

                // Remove old handler if exists (not strictly needed since we rebuild, but good practice)
                if (userMarker._hideHandler) {
                    userMarker.off('move', userMarker._hideHandler);
                }

                // Initial check
                checkAndHide();

                // Bind
                userMarker._hideHandler = checkAndHide;
                userMarker.on('move', checkAndHide);
            };

            const updatePolygonVisuals = (state, lineMap) => {
                const pct = Math.floor((state.current / state.total) * 100);

                // Update Label
                if (state.label) {
                    const icon = state.label.options.icon;
                    // Safe update of HTML
                    icon.options.html = icon.options.html.replace(/>\d+%</, `>${pct}%<`);
                    state.label.setIcon(icon);
                }

                // Progress is tracked via visiblePolygonIds and persisted to Redis via saveLocationState()


                // Check Completion
                if (state.current >= state.total) {
                    console.log("DEBUG: Polygon Completed! Moving to Persistent Layer.");

                    // 1. Turn Green & Move to Persistent Layer
                    // Remove from detailsLayer (which hides on zoom out)
                    // Ensure it is explicitly removed from the hiding detailsLayer
                    if (detailsLayer.hasLayer(state.layer)) {
                        detailsLayer.removeLayer(state.layer);
                    } else {
                        state.layer.remove();
                    }

                    // Add to completedLayer (visible everywhere)
                    if (!completedPolygonsLayer.hasLayer(state.layer)) {
                        completedPolygonsLayer.addLayer(state.layer);
                    }

                    state.layer.setStyle({
                        color: 'transparent',
                        fillColor: 'transparent',
                        fillOpacity: 0,
                        stroke: false
                    });

                    // Reveal poster part
                    console.log(`DEBUG: Calling revealPolygonPart for polygon ${state.id}`);
                    console.log(`DEBUG: Polygon coords:`, state.coords);
                    revealPolygonPart(state.coords);
                    console.log(`DEBUG: Current clipPath paths count:`, revealMask ? revealMask.children.length : 'no mask');

                    // 2. Remove/Hide Label from map (could be in detailsLayer or expandedLayer)
                    // In debug mode, keep label visible but update it to show 100%
                    if (state.label) {
                        if (!isPostersDebugActive) {
                            // Normal mode: remove label
                            if (detailsLayer.hasLayer(state.label)) {
                                detailsLayer.removeLayer(state.label);
                            } else if (expandedLayer.hasLayer(state.label)) {
                                expandedLayer.removeLayer(state.label);
                            } else {
                                state.label.remove(); // Remove from any layer
                            }
                            state.label = null;
                        }
                        // In debug mode: label stays visible with 100%
                    }
                    if (state.promo) {
                        if (!isPostersDebugActive) {
                            // Normal mode: remove promo
                            if (detailsLayer.hasLayer(state.promo)) {
                                detailsLayer.removeLayer(state.promo);
                            } else if (expandedLayer.hasLayer(state.promo)) {
                                expandedLayer.removeLayer(state.promo);
                            } else {
                                state.promo.remove(); // Remove from any layer
                            }
                            state.promo = null;
                        }
                        // In debug mode: promo stays visible
                    }
                    if (state.debugBox) {
                        // debugBox always kept for debug functionality
                        // (already only created in debug mode)
                    }
                    console.log("DEBUG: Polygon Completed! Moving to Persistent Layer.");

                    // 3. Hide White Lines and Green Circles on those lines
                    // DISABLE HIDING per user request (Keep white lines visible)
                    /*
                    if (state.lines) {
                        state.lines.forEach(lid => {
                            const lineLayer = lineMap.get(String(lid));
                            if (lineLayer) {
                                lineLayer.setStyle({ opacity: 0, fillOpacity: 0 });
                                // Note: This might hide a line shared with an INCOMPLETE polygon.
                                // User requested: "when in perimeter of polygon no visible circles left... disappear white lines in this perimeter"
                                // This implies strict removal.
                            }

                            // Hide green circles on this line
                            const greenCircles = greenCirclesByLine.get(String(lid));
                            if (greenCircles && !isPostersDebugActive) {
                                greenCircles.forEach(circleLayer => {
                                    if (typeof circleLayer.setStyle === 'function') {
                                        circleLayer.setStyle({ opacity: 0, fillOpacity: 0 });
                                    }
                                });
                            }
                        });
                    }
                    */

                    // 4. Hide ALL circles at polygon vertices (blue/white circles on boundary)
                    if (state.coords && circleLayerMap) {
                        state.coords.forEach(coord => {
                            const key = `${coord[0].toFixed(6)},${coord[1].toFixed(6)}`;
                            const circleLayer = circleLayerMap.get(key);
                            if (circleLayer && !isPostersDebugActive) {
                                // Hide the circle completely
                                if (typeof circleLayer.setStyle === 'function') {
                                    circleLayer.setStyle({ opacity: 0, fillOpacity: 0 });
                                }
                            }
                        });
                    }
                }
            };

            // Listen for keyboard navigation requests
            let lastFacingDirection = 'left'; // Marker GIF faces left by default

            document.addEventListener('map-move-request', (e) => {
                const { lat, lon, direction } = e.detail;

                // Flip marker GIF based on direction
                if (direction) {
                    const isLeft = direction.includes('LEFT');
                    const isRight = direction.includes('RIGHT');
                    const markerGif = document.getElementById('marker-gif');

                    if (isRight && lastFacingDirection !== 'right' && markerGif) {
                        // Flip to face right (mirror the left-facing GIF)
                        markerGif.style.transform = 'translateY(-25%) scaleX(-1)';
                        lastFacingDirection = 'right';
                    } else if (isLeft && lastFacingDirection !== 'left' && markerGif) {
                        // Return to normal (GIF faces left naturally)
                        markerGif.style.transform = 'translateY(-25%)';
                        lastFacingDirection = 'left';
                    }
                }

                // Move marker
                userMarker.setLatLng([lat, lon]);
                updateAndSaveUserPosition(userMarker, lat, lon);

                // Ensure map centers on it
                map.panTo([lat, lon]);
            });

            // Function to check if a line segment intersects with a rectangle (debug box)
            const lineIntersectsRect = (lineStart, lineEnd, rectBounds) => {
                // lineStart, lineEnd = [lat, lng]
                // rectBounds = { north, south, east, west }

                // Rectangle corners
                const rectCorners = [
                    [rectBounds.north, rectBounds.west],  // Top-left
                    [rectBounds.north, rectBounds.east],  // Top-right
                    [rectBounds.south, rectBounds.east],  // Bottom-right
                    [rectBounds.south, rectBounds.west]   // Bottom-left
                ];

                const rectEdges = [
                    [rectCorners[0], rectCorners[1]], // Top edge
                    [rectCorners[1], rectCorners[2]], // Right edge
                    [rectCorners[2], rectCorners[3]], // Bottom edge
                    [rectCorners[3], rectCorners[0]]  // Left edge
                ];

                // Check if line endpoints are inside rectangle
                const p1Inside = lineStart[0] >= rectBounds.south && lineStart[0] <= rectBounds.north &&
                    lineStart[1] >= rectBounds.west && lineStart[1] <= rectBounds.east;
                const p2Inside = lineEnd[0] >= rectBounds.south && lineEnd[0] <= rectBounds.north &&
                    lineEnd[1] >= rectBounds.west && lineEnd[1] <= rectBounds.east;

                if (p1Inside || p2Inside) {
                    console.log(`  Point inside: p1=${p1Inside}, p2=${p2Inside}`);
                    return true;
                }

                // Check line-line intersection for each rectangle edge
                const doSegmentsIntersect = (p1, p2, p3, p4) => {
                    // p1,p2 = line segment, p3,p4 = rectangle edge
                    // Using CCW algorithm
                    const ccw = (A, B, C) => {
                        return (C[1] - A[1]) * (B[0] - A[0]) > (B[1] - A[1]) * (C[0] - A[0]);
                    };
                    const result = ccw(p1, p3, p4) !== ccw(p2, p3, p4) && ccw(p1, p2, p3) !== ccw(p1, p2, p4);
                    return result;
                };

                for (let i = 0; i < rectEdges.length; i++) {
                    const edge = rectEdges[i];
                    if (doSegmentsIntersect(lineStart, lineEnd, edge[0], edge[1])) {
                        console.log(`  Intersects edge ${i}: ${edge[0]} -> ${edge[1]}`);
                        return true;
                    }
                }

                return false;
            };

            // Function to update white line colors based on debug box intersections
            const updateDebugBoxIntersections = () => {
                if (!_polygonState || !_lineLayerMap) return;

                console.log('DEBUG: Checking debug box intersections...');

                _polygonState.forEach(state => {
                    if (!state.debugBox || !state.lines) return;

                    const map = state.debugBox._map;
                    if (!map) return;

                    // Get debug box center (polygon center) and icon properties
                    const boxCenter = state.debugBox.getLatLng();
                    const icon = state.debugBox.options.icon;
                    const iconSize = icon.options.iconSize; // [width, height]
                    const iconAnchor = icon.options.iconAnchor; // [x, y] from top-left to center point

                    // Calculate the four corners of the debug box in lat/lng
                    // iconAnchor tells us where the center point is within the icon
                    // So the box extends from center - anchor to center + (size - anchor)

                    const centerPoint = map.latLngToLayerPoint(boxCenter);

                    // Calculate pixel bounds
                    const topLeftPx = {
                        x: centerPoint.x - iconAnchor[0],
                        y: centerPoint.y - iconAnchor[1]
                    };
                    const bottomRightPx = {
                        x: topLeftPx.x + iconSize[0],
                        y: topLeftPx.y + iconSize[1]
                    };

                    // Convert to lat/lng
                    const topLeft = map.layerPointToLatLng([topLeftPx.x, topLeftPx.y]);
                    const bottomRight = map.layerPointToLatLng([bottomRightPx.x, bottomRightPx.y]);
                    const topRight = map.layerPointToLatLng([bottomRightPx.x, topLeftPx.y]);
                    const bottomLeft = map.layerPointToLatLng([topLeftPx.x, bottomRightPx.y]);

                    const rectBounds = {
                        north: Math.max(topLeft.lat, topRight.lat, bottomLeft.lat, bottomRight.lat),
                        south: Math.min(topLeft.lat, topRight.lat, bottomLeft.lat, bottomRight.lat),
                        east: Math.max(topLeft.lng, topRight.lng, bottomLeft.lng, bottomRight.lng),
                        west: Math.min(topLeft.lng, topRight.lng, bottomLeft.lng, bottomRight.lng)
                    };

                    console.log(`DEBUG: Box bounds for polygon at (${boxCenter.lat}, ${boxCenter.lng}):`, rectBounds);

                    // Check each boundary line
                    state.lines.forEach(lineId => {
                        const lineComposite = _lineLayerMap.get(String(lineId));
                        if (!lineComposite || !lineComposite.visual) return;

                        const lineLatLngs = lineComposite.visual.getLatLngs();

                        // Check each segment of the polyline
                        let intersects = false;
                        for (let i = 0; i < lineLatLngs.length - 1; i++) {
                            const start = [lineLatLngs[i].lat, lineLatLngs[i].lng];
                            const end = [lineLatLngs[i + 1].lat, lineLatLngs[i + 1].lng];

                            if (lineIntersectsRect(start, end, rectBounds)) {
                                intersects = true;
                                console.log(`DEBUG: Line segment [${start}] -> [${end}] intersects box`);
                                break;
                            }
                        }

                        // Change color if intersects
                        if (intersects) {
                            lineComposite.visual.setStyle({ color: 'blue' });
                            console.log(`DEBUG: Line ${lineId} intersects with debug box - colored blue`);
                        }
                    });
                });
            };

            // Function to reset all white lines to original color
            const resetWhiteLineColors = () => {
                if (!_lineLayerMap) return;

                console.log('DEBUG: Resetting white line colors...');

                _lineLayerMap.forEach((lineComposite, lineId) => {
                    if (lineComposite && lineComposite.visual) {
                        lineComposite.visual.setStyle({ color: 'white' });
                    }
                });
            };

            // Handle Debug Mode Toggles (via map_controls.js or top bar)
            document.addEventListener('debug-mode-change', (e) => {
                isDebugActive = e.detail.active;
                const postersBtn = document.getElementById('btn-debug-posters');
                if (isDebugActive) {
                    postersBtn.style.display = 'flex';
                } else {
                    postersBtn.style.display = 'none';
                    isPostersDebugActive = false;
                    postersBtn.classList.remove('active');
                    updatePostersVisibility();
                }
            });

            // --- THE REVEAL MAGIC (SVG CLIP PATHS) ---
            const revealPolygonPart = (coords) => {
                console.log("REVEAL: revealPolygonPart called", { coords, revealMask });
                if (!revealMask || !coords || !posterSvgOverlay) {
                    console.warn("REVEAL: Skipping - no mask, coords or overlay", { revealMask, coords });
                    return;
                }

                try {
                    const svgBounds = posterSvgOverlay.getBounds();
                    const svgMinLat = svgBounds.getSouth();
                    const svgMaxLat = svgBounds.getNorth();
                    const svgMinLon = svgBounds.getWest();
                    const svgMaxLon = svgBounds.getEast();
                    const latRange = svgMaxLat - svgMinLat;
                    const lonRange = svgMaxLon - svgMinLon;

                    const points = coords.map(p => {
                        if (!Array.isArray(p) || p.length < 2) return null;
                        // Scale coordinates to 0-1000 range relative to SVG bounds
                        const x = ((p[1] - svgMinLon) / lonRange) * 1000;
                        const y = ((svgMaxLat - p[0]) / latRange) * 1000;
                        return `${x.toFixed(2)},${y.toFixed(2)}`;
                    }).filter(Boolean).join(' ');

                    const pathData = points ? `M ${points} Z` : '';

                    if (!pathData) {
                        console.warn("REVEAL: No valid pathData generated");
                        return;
                    }

                    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    path.setAttribute("d", pathData);
                    revealMask.appendChild(path);
                    console.log("REVEAL: Polygon added to mask. Total paths:", revealMask.children.length);
                } catch (e) {
                    console.error("Failed to reveal polygon part:", e);
                }
            };



            // Navigation / Top Bar Logic (with cache-busting)
            fetch(`/B_map_page/components/top_bar.html?v=${Date.now()}`)
                .then(response => response.text())
                .then(html => {
                    document.getElementById('top-bar-container').innerHTML = html;
                    initTopBarEvents();
                })
                .catch(err => console.error('Error loading top bar:', err));

            // Initial Auto-Start
            // isGpsActive = false; // REMOVED

            // CRITICAL: Initialize game - check Redis for saved state first, otherwise generate fresh
            const initializeGame = async () => {
                console.log(`DEBUG: === INITIALIZING GAME ===`);

                try {
                    // STEP 1: Check for saved global state in Redis
                    const savedState = await loadGlobalState();

                    if (savedState) {
                        console.log(`DEBUG: ✅ Found saved global state - restoring without regeneration`);

                        // Show loading indicator
                        loadingGif.style.display = 'block';
                        loadingGif.style.opacity = '1';
                        mapElement.style.opacity = '0.3';
                        hasRevealed = false;

                        // Render from saved state
                        await renderFromSavedState(savedState);

                        // Reveal map
                        revealMap();

                        console.log(`DEBUG: ✅ Game restored from Redis - ${savedState.polygons.length} polygons, marker at ${currentCircleUid || 'position'}`);
                        return;
                    }

                    // STEP 2: No saved state - generate fresh (first time or after server restart)
                    console.log(`DEBUG: No saved state found - generating fresh map`);

                    let initialLat = DEFAULT_LAT;
                    let initialLon = DEFAULT_LON;

                    console.log(`DEBUG: Starting at default location: ${initialLat}, ${initialLon}`);

                    // Generate new game data
                    await loadGameData(initialLat, initialLon);

                } catch (e) {
                    console.error(`DEBUG: Error during game initialization:`, e);
                    // Fallback: try to generate fresh
                    await loadGameData(DEFAULT_LAT, DEFAULT_LON);
                }
            };

            // Start game initialization
            initializeGame();

            const initTopBarEvents = () => {
                // const gpsBtn = document.getElementById('gps-btn'); // REMOVED
                const debugBtn = document.getElementById('debug-btn');
                const menuBtn = document.getElementById('menu-btn');
                const topBar = document.getElementById('top-bar');

                const closeMenu = () => {
                    if (topBar && topBar.classList.contains('expanded')) {
                        topBar.classList.remove('expanded');
                    }
                };

                // Get .black-square for background change
                const blackSquare = document.querySelector('.black-square');

                if (debugBtn) {
                    debugBtn.addEventListener('click', () => {
                        isDebugActive = !isDebugActive;
                        if (isDebugActive) {
                            console.log("DEBUG: Debug Mode ENABLED");
                            debugBtn.classList.add('active');
                            // Add Class to Body for global styling
                            document.body.classList.add('debug-mode');

                            // Check for debug box intersections with white lines
                            updateDebugBoxIntersections();

                        } else {
                            console.log("DEBUG: Debug Mode DISABLED");
                            debugBtn.classList.remove('active');
                            // Remove Class
                            document.body.classList.remove('debug-mode');

                            // Reset all white lines to original color
                            resetWhiteLineColors();

                            map.closePopup();
                            resetSelection();
                        }

                        // Dispatch event for posters button visibility
                        document.dispatchEvent(new CustomEvent('debug-mode-change', {
                            detail: { active: isDebugActive }
                        }));
                    });
                }






                if (menuBtn && topBar) {
                    menuBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        topBar.classList.toggle('expanded');
                    });
                }

                // POSTERS Button Handler (now in top bar)
                const btnDebugPosters = document.getElementById('btn-debug-posters');
                if (btnDebugPosters) {
                    btnDebugPosters.addEventListener('click', () => {
                        isPostersDebugActive = !isPostersDebugActive;
                        btnDebugPosters.classList.toggle('active', isPostersDebugActive);
                        updatePostersVisibility();
                    });
                }

                mapElement.addEventListener('click', closeMenu);
            };
        });
    </script>
</body>

</html>