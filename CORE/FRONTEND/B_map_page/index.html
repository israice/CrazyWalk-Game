<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Map Location</title>
    <script>
        // Mask URL to show only root address
        window.history.replaceState(null, '', '/');
    </script>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            /* Fallback */
            height: 100dvh;
            /* Dynamic viewport height */
            overflow: hidden;
            background-color: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
        }

        /* Container for the map content */
        .black-square {
            position: absolute;
            width: 146vh;
            height: 82vh;
            background-color: #050505;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 0;
            overflow: hidden;
            /* Ensure map doesn't spill out */
        }

        /* The Map itself */
        #map {
            width: 100%;
            height: 100%;
            background: #050505;
            opacity: 0;
            transition: opacity 0.8s ease-in-out;
            z-index: 1;
        }

        /* Loader GIF */
        #loading-gif {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            /* Centered in the square */
            width: 150vh;
            /* Adjust size as appropriate */
            height: 150vh;
            object-fit: contain;
            z-index: 10;
            transition: opacity 0.6s ease-out;
        }

        /* The Phone Frame */
        .phone-frame {
            height: 200vh;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-90deg);
            z-index: 100;
            /* On top of everything */
            pointer-events: none;
        }



        /* Leaflet DivIcon Custom Style for Marker */
        .leaftlet-div-icon {
            background: transparent !important;
            border: none !important;
        }

        /* Mobile Responsive */
        @media (max-width: 1024px) {
            .phone-frame {
                display: none !important;
            }

            .black-square {
                width: 100vh;
                /* Fallback */
                width: 100dvh;
                /* Match dynamic screen height when rotated */
                height: 100vw;
                border-radius: 0;
                transform: translate(-50%, -50%) rotate(90deg);
                /* Rotate interface 90 degrees for mobile */
            }


        }

        /* Label Styles */
        .leaflet-tooltip.circle-label {
            background: transparent;
            border: none;
            box-shadow: none;
            color: white;
            font-weight: bold;
            font-size: 20px;
            text-shadow: 0 0 2px black;
        }
    </style>
</head>

<body>
    <div class="black-square">
        <div id="map"></div>

        <div id="top-bar-container"></div>
        <img id="loading-gif" src="/B_map_page/components/earth.gif" alt="Loading...">
    </div>
    <img class="phone-frame" src="/B_map_page/components/iphone.png" alt="Phone Frame">

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <!-- Map Controls Logic -->
    <script src="/B_map_page/components/map_controls.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const mapElement = document.getElementById('map');
            const loadingGif = document.getElementById('loading-gif');
            let hasRevealed = false;

            // Default coordinates
            const DEFAULT_LAT = 32.05688;
            const DEFAULT_LON = 34.76878;
            let isGpsActive = false;
            let hasPreciseFix = false;

            // Initialize Map via MapControls (Centralized Logic)
            const controls = new MapControls('map', [DEFAULT_LAT, DEFAULT_LON], {
                defaultZoom: 18,
                minZoom: 3,  // Unrestricted Zoom Out
                maxZoom: 18  // Max Zoom In
            });
            const map = controls.getMap();

            // Initialize Layer Groups
            const groupsLayer = L.layerGroup().addTo(map);
            const detailsLayer = L.layerGroup().addTo(map);

            // Visibility Rules
            // 1. Details (Polygons, Lines, Circles) -> Visible ONLY at Zoom 18
            controls.addVisibilityRule(detailsLayer, 18);

            // 2. Groups (Monolith) -> Always visible 18+ (base layer)
            // controls.addVisibilityRule(groupsLayer, 18);

            // Custom Marker Icon (Visual)
            // Goal: Purple Circle (Shadow) is centered on the LatLon (Anchor). GIF stands on top.
            const customIcon = L.divIcon({
                className: 'custom-marker',
                html: `
                    <div style="transform: translate(-50%, -50%); position: relative; display: flex; align-items: center; justify-content: center;">
                        <div style="position: absolute; width: 4vh; height: 4vh; background-color: #9900ff; border: 2px solid white; border-radius: 50%; box-shadow: 0 0 15px #9900ff; opacity: 0.8; transform: perspective(500px) rotateX(45deg);"></div>
                        <img src="/B_map_page/components/marker.gif" style="position: relative; z-index: 2; width: 8vh; height: auto; transform: translateY(-25%); bottom: 2vh;">
                    </div>
                `,
                iconSize: null,
                iconAnchor: [0, 0]
            });

            // Create Marker pinned to map
            const userMarker = L.marker([DEFAULT_LAT, DEFAULT_LON], {
                icon: customIcon,
                zIndexOffset: 1000
            }).addTo(map);

            // Reveal Map Logic (Visual Transition)
            const revealMap = () => {
                if (hasRevealed) return;
                hasRevealed = true;
                console.log("DEBUG: Revealing Map...");
                map.invalidateSize();
                loadingGif.style.opacity = '0';
                mapElement.style.opacity = '1';
                setTimeout(() => {
                    loadingGif.style.display = 'none';
                }, 600);
            };

            // Safety Reveal
            setTimeout(() => {
                if (!hasRevealed) {
                    console.warn("DEBUG: Safety Reveal Triggered (Data took too long)");
                    revealMap();
                }
            }, 30000);

            // Reusable function to process coordinates (Logic)
            const processCoordinates = (lat, lon, accuracy, label) => {
                console.log(`DEBUG: [Map Page] Processing ${label} Position: ${lat}, ${lon} (Acc: ${accuracy}m)`);

                if (label === 'LOW_ACCURACY' && hasPreciseFix) {
                    console.log("DEBUG: Ignoring Low Accuracy update (Precise already found).");
                    return;
                }

                if (label === 'HIGH_ACCURACY') {
                    hasPreciseFix = true;
                }

                // Use Controls to update position (Enforces map follow rules)
                controls.updateUserPosition(userMarker, lat, lon, isGpsActive);

                if (isGpsActive) {
                    if (label === 'HIGH_ACCURACY' && accuracy > 200) {
                        console.warn(`Warning: GPS signal weak (${Math.round(accuracy)}m).`);
                    }

                    // Trigger Data Load if this is a fresh session
                    if (!window.hasLoadedGpsData) {
                        window.hasLoadedGpsData = true;
                        console.log("DEBUG: Triggering GPS Game Data Load (Accuracy: " + label + ")");
                        loadGameData(lat, lon);
                    }
                }

                // Background: Send to server
                fetch(`/api/locate?lat=${lat}&lon=${lon}`)
                    .then(res => res.json())
                    .then(data => console.log("DEBUG: Server ack:", data))
                    .catch(err => console.warn("DEBUG: Server sync failed (non-critical):", err));
            };

            const loadGameData = (lat, lon) => {
                console.log("DEBUG: Fetching Game Data...");

                // Show Loading GIF and dim map (Visual Transition)
                loadingGif.style.display = 'block';
                loadingGif.style.opacity = '1';
                mapElement.style.opacity = '0.3';
                hasRevealed = false;

                console.log(`DEBUG: Fetching Game Data from /api/game_data?lat=${lat}&lon=${lon}`);

                fetch(`/api/game_data?lat=${lat}&lon=${lon}`)
                    .then(res => {
                        console.log("DEBUG: Response Status:", res.status);
                        return res.json();
                    })
                    .then(data => {
                        console.log("DEBUG: Game Data JSON Received. Keys:", Object.keys(data));
                        renderGameElements(data);
                        revealMap();
                    })
                    .catch(err => {
                        console.error("DEBUG: Game Data Failed", err);
                        revealMap();
                    });
            };

            // VISUALS: Rendering Colors and Layers
            const renderGameElements = (data) => {
                console.log("DEBUG: Starting Render...");

                // 0. Groups (Monolith) - Managed by Layer Group for Visibility Rules
                groupsLayer.clearLayers();
                detailsLayer.clearLayers();

                // Track Layers for Hiding Logic
                // Key: "lat,lon" (Fixed precision 6) -> Layer
                const circleLayerMap = new Map();
                const addToMap = (lat, lon, layer) => {
                    const key = `${lat.toFixed(6)},${lon.toFixed(6)}`;
                    circleLayerMap.set(key, layer);
                };

                if (data.groups) {
                    console.log(`DEBUG: Rendering ${data.groups.length} Groups into LayerGroup`);
                    data.groups.forEach(group => {
                        L.polygon(group.coords, {
                            color: '#333',       // Visual Rule
                            stroke: false,
                            fillColor: '#222',
                            fillOpacity: 0.3,
                            weight: 0
                        }).addTo(groupsLayer);
                    });
                }

                // 1. Polygons (Details)
                if (data.polygons) {
                    data.polygons.forEach(poly => {
                        L.polygon(poly.coords, {
                            color: 'purple',    // Visual Rule
                            fillColor: 'purple',
                            fillOpacity: 0.1,
                            weight: 0
                        }).addTo(detailsLayer);

                        if (poly.center) {
                            L.marker([poly.center[0], poly.center[1]], {
                                icon: L.divIcon({
                                    className: 'poly-label',
                                    html: `<div style="background:white; border-radius:50%; width:20px; height:20px; text-align:center; line-height:20px; color:black; font-size:10px; opacity: 0.8;">${poly.percentage}%</div>`,
                                    iconSize: [20, 20],
                                    iconAnchor: [10, 10]
                                })
                            }).addTo(detailsLayer);
                        }
                    });
                }

                // 2. Red Lines (Base or Details? Assuming Details as it is clutter)
                // Actually assuming details.
                if (data.red_lines && data.red_lines.length > 0) {
                    data.red_lines.forEach(line => {
                        L.polyline(line, { color: 'red', weight: 4, opacity: 0.6 }).addTo(detailsLayer);
                    });
                }

                // 3. White Lines (Details)
                if (data.white_lines) {
                    controls.setSnapLines(data.white_lines); // Enable Snapping
                    data.white_lines.forEach(line => {
                        L.polyline(line.path, { color: 'white', weight: 2, dashArray: '5, 5' }).addTo(detailsLayer);
                    });

                    // FORCE RESNAP: Now that lines are known, update marker to closest point
                    const currentPos = userMarker.getLatLng();
                    console.log("DEBUG: Re-snapping after line load...");
                    controls.updateUserPosition(userMarker, currentPos.lat, currentPos.lng, isGpsActive);
                }

                // 4. Blue Circles (Details)
                if (data.blue_circles) {
                    data.blue_circles.forEach(circle => {
                        const marker = L.circleMarker([circle.lat, circle.lon], {
                            radius: 8,
                            color: 'blue',
                            fillColor: '#00ccff',
                            fillOpacity: 0.8
                        }).addTo(detailsLayer);

                        marker.bindTooltip(String(circle.connections), { permanent: true, direction: 'center', className: 'circle-label' });
                        addToMap(circle.lat, circle.lon, marker);
                    });
                }

                // 5. Green Circles (Details)
                if (data.green_circles) {
                    data.green_circles.forEach(circle => {
                        const marker = L.circleMarker([circle.lat, circle.lon], {
                            radius: 4,
                            color: 'green',
                            fillColor: '#00ff00',
                            fillOpacity: 1
                        }).addTo(detailsLayer);
                        addToMap(circle.lat, circle.lon, marker);
                    });
                }

                // Triggers visibility check immediately
                controls.checkVisibility();

                // 6. Update Navigation Graph (Strict Topology)
                controls.updateGraph(data.green_circles, data.blue_circles, data.white_lines);

                // 7. Setup Auto-Hiding Logic (Closure retains circleLayerMap)
                setupNodeHiding(circleLayerMap);
            };

            let currentHiddenLayer = null;
            const setupNodeHiding = (layerMap) => {
                const checkAndHide = () => {
                    const pos = userMarker.getLatLng();
                    const key = `${pos.lat.toFixed(6)},${pos.lng.toFixed(6)}`;

                    // Logic Change: Do NOT restore previous layers.
                    // Circles should stay hidden once visited (Pac-Man style).

                    const target = layerMap.get(key);
                    if (target) {
                        // Check if already hidden to avoid redundant style calcs
                        if (target.options.opacity !== 0) {
                            target.setStyle({ opacity: 0, fillOpacity: 0 });
                            if (target.getTooltip && target.getTooltip()) {
                                target.closeTooltip();
                            }
                        }
                    }
                };

                // Run immediately
                checkAndHide();

                if (userMarker._hideHandler) {
                    userMarker.off('move', userMarker._hideHandler);
                }
                userMarker._hideHandler = checkAndHide;
                userMarker.on('move', checkAndHide);
            };

            // Listen for keyboard navigation requests
            document.addEventListener('map-move-request', (e) => {
                const { lat, lon } = e.detail;
                // Move marker directly without re-snapping (we assume the graph node is already snapped/valid)
                // But utilizing updateUserPosition ensures consistency if we want it.
                // However, updateUserPosition calls getSnappedPosition AGAIN.
                // If graph nodes are accurate, this is fine.
                controls.updateUserPosition(userMarker, lat, lon, isGpsActive);

                // Ensure map centers on it
                map.panTo([lat, lon]);
            });

            const startLocationWatch = () => {
                console.log("DEBUG: [Map Page] Starting Parallel Geolocation Strategy...");
                if (!("geolocation" in navigator)) {
                    alert("Geolocation not supported by this browser.");
                    return;
                }

                hasPreciseFix = false;

                // 1. FAST LANE
                navigator.geolocation.getCurrentPosition(
                    (pos) => processCoordinates(pos.coords.latitude, pos.coords.longitude, pos.coords.accuracy, 'LOW_ACCURACY'),
                    (err) => console.warn("DEBUG: Fast Lane (Low Acc) failed:", err),
                    { enableHighAccuracy: false, timeout: 5000, maximumAge: Infinity }
                );

                // 2. PRECISION LANE
                navigator.geolocation.getCurrentPosition(
                    (pos) => processCoordinates(pos.coords.latitude, pos.coords.longitude, pos.coords.accuracy, 'HIGH_ACCURACY'),
                    (err) => {
                        console.warn("DEBUG: Precision Lane (High Acc) failed:", err);
                        if (err.code === err.TIMEOUT && !hasPreciseFix) {
                            console.log("DEBUG: High Accuracy timed out.");
                        } else if (err.code === err.PERMISSION_DENIED) {
                            alert("Please allow Location Access to use GPS.");
                        }
                    },
                    { enableHighAccuracy: true, timeout: 20000, maximumAge: 0 }
                );
            };

            // Navigation / Top Bar Logic 
            fetch('/B_map_page/components/top_bar.html')
                .then(response => response.text())
                .then(html => {
                    document.getElementById('top-bar-container').innerHTML = html;
                    initTopBarEvents();
                })
                .catch(err => console.error('Error loading top bar:', err));

            // Initial Auto-Start
            isGpsActive = false;
            loadGameData(DEFAULT_LAT, DEFAULT_LON);

            const initTopBarEvents = () => {
                const gpsBtn = document.getElementById('gps-btn');
                const menuBtn = document.getElementById('menu-btn');
                const topBar = document.getElementById('top-bar');

                const closeMenu = () => {
                    if (topBar && topBar.classList.contains('expanded')) {
                        topBar.classList.remove('expanded');
                    }
                };

                if (gpsBtn) {
                    gpsBtn.addEventListener('click', () => {
                        isGpsActive = !isGpsActive;

                        if (isGpsActive) {
                            console.log("DEBUG: GPS Toggled ON");
                            gpsBtn.classList.add('active');
                            startLocationWatch();
                        } else {
                            console.log("DEBUG: GPS Toggled OFF. Reverting to default.");
                            gpsBtn.classList.remove('active');
                            hasPreciseFix = false;

                            // Use Controls to reset view
                            controls.resetView(DEFAULT_LAT, DEFAULT_LON);
                            userMarker.setLatLng([DEFAULT_LAT, DEFAULT_LON]);

                            // Trigger load to show animation and refresh data
                            loadGameData(DEFAULT_LAT, DEFAULT_LON);
                        }
                    });
                }

                if (menuBtn && topBar) {
                    menuBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        topBar.classList.toggle('expanded');
                    });
                }

                mapElement.addEventListener('click', closeMenu);
            };
        });
    </script>
</body>

</html>