<!DOCTYPE html>
<html lang="en">

<head>
    <script>
        // CLEANUP: Force clear all local domain data on entry
        try {
            // localStorage.clear(); // MODIFIED: Logic removed to allow persistence of Green Polygons
            // sessionStorage.clear(); // Optional: We can keep session clear if we want fresh session but persisted progress.
            // Let's keep data for now as user wants "existing" green polygons.
            if ('caches' in window) {
                caches.keys().then(names => {
                    for (let name of names) caches.delete(name);
                });
            }
            console.log("Domain storage cleanup skipped (Persistence enabled).");
        } catch (e) {
            console.warn("Storage cleanup failed:", e);
        }
    </script>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Map Location</title>
    <script>
        // Mask URL to show only root address
        window.history.replaceState(null, '', '/');
    </script>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            /* Fallback */
            height: 100dvh;
            /* Dynamic viewport height */
            overflow: hidden;
            background-color: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
        }

        /* Container for the map content */
        .black-square {
            position: absolute;
            width: 146vh;
            height: 82vh;
            background-color: #050505;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 0;
            overflow: hidden;
            /* Ensure map doesn't spill out */
        }

        /* The Map itself */
        #map {
            width: 100%;
            height: 100%;
            background: #050505;
            opacity: 0;
            transition: opacity 0.8s ease-in-out;
            z-index: 1;
        }

        /* Loader GIF */
        #loading-gif {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            /* Centered in the square */
            width: 150vh;
            /* Adjust size as appropriate */
            height: 150vh;
            object-fit: contain;
            z-index: 10;
            transition: opacity 0.6s ease-out;
        }

        /* The Phone Frame */
        .phone-frame {
            height: 200vh;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-90deg);
            z-index: 100;
            /* On top of everything */
            pointer-events: none;
        }



        /* Leaflet DivIcon Custom Style for Marker */
        .leaftlet-div-icon {
            background: transparent !important;
            border: none !important;
        }

        /* Mobile Responsive */
        @media (max-width: 1024px) {
            .phone-frame {
                display: none !important;
            }

            .black-square {
                width: 100vh;
                /* Fallback */
                width: 100dvh;
                /* Match dynamic screen height when rotated */
                height: 100vw;
                border-radius: 0;
                transform: translate(-50%, -50%) rotate(90deg);
                /* Rotate interface 90 degrees for mobile */
            }


        }

        /* Label Styles */
        .leaflet-tooltip.circle-label {
            background: transparent;
            border: none;
            box-shadow: none;
            color: white;
            font-weight: bold;
            font-size: 20px;
            text-shadow: 0 0 2px black;
            pointer-events: none;
            /* Make tooltip transparent to clicks */
        }


        /* Debug Mode Styles */
        body.debug-mode .black-square,
        body.debug-mode #map,
        body.debug-mode .leaflet-container {
            background-color: #001a4d !important;
        }

        /* Tint Tiles Blue in Debug Mode (Invert Light Map to Dark Blue) */
        body.debug-mode .leaflet-tile-pane {
            opacity: 1 !important;
            filter: invert(100%) hue-rotate(180deg) brightness(80%) contrast(110%) !important;
        }

        .street-label-tooltip {
            background: transparent;
            border: none;
            box-shadow: none;
            color: #fff;
            /* White text for Dark Map (Default) */
            font-size: 11px;
            font-weight: bold;
            text-shadow: 0px 0px 2px #000;
            /* Halo */
        }

        /* Invert Label Color in Debug Mode */
        /* Invert Label Color in Debug Mode */
        /* Invert Label Color in Debug Mode */
        body.debug-mode .street-label-tooltip {
            color: #000;
            text-shadow: 0px 0px 2px rgba(255, 255, 255, 0.8);
        }

        /* ERROR SCREEN */
        #error-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #ff0033;
            /* Bright Red */
            z-index: 1000;
            display: none;
            /* Hidden by default */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 5vh;
        }

        #error-screen h1 {
            font-size: 4vh;
            color: white;
            background: none;
            -webkit-text-fill-color: white;
            margin-bottom: 2vh;
        }

        #error-screen p {
            font-size: 2vh;
            color: white;
            opacity: 0.9;
            max-width: 80%;
            margin-bottom: 4vh;
        }

        .btn-retry {
            background: white;
            color: #ff0033;
            border: none;
            padding: 1.5vh 4vh;
            font-size: 2vh;
            font-weight: 700;
            border-radius: 1vh;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s;
        }

        .btn-retry:active {
            transform: scale(0.95);
        }

        /* Allow text selection in popups */
        .leaflet-popup-content {
            -webkit-user-select: text !important;
            -ms-user-select: text !important;
            user-select: text !important;
            cursor: auto;
        }
    </style>
</head>

<body>
    <div class="black-square">
        <div id="map"></div>

        <div id="top-bar-container" style="opacity: 0; transition: opacity 0.8s ease-in-out;"></div>
        <img id="loading-gif" src="/B_map_page/components/earth.gif" alt="Loading...">

        <!-- Red Error Screen -->
        <div id="error-screen">
            <!-- Icon will be inserted dynamically or can use unicode if FontAwesome not loaded, but user has it cached? -->
            <!-- Using SVG or simple text to be safe if FA not present on map page (it wasn't in head) -->
            <div style="font-size: 8vh; color: white; margin-bottom: 2vh;">&#9888;</div>
            <h1>CRITICAL ERROR</h1>
            <p id="error-message">No map data found.</p>
            <button class="btn-retry" id="retry-btn">RETRY</button>
        </div>

    </div>
    <img class="phone-frame" src="/B_map_page/components/iphone.png" alt="Phone Frame">

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <!-- Map Controls Logic -->
    <script src="/B_map_page/components/map_controls.js?v=3"></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const mapElement = document.getElementById('map');
            const loadingGif = document.getElementById('loading-gif');
            let hasRevealed = false;

            // Default coordinates
            const DEFAULT_LAT = 32.05688;
            const DEFAULT_LON = 34.76878;
            let isGpsActive = false;
            let hasPreciseFix = false;
            let isDebugActive = false; // New Debug State

            // Initialize Map via MapControls (Centralized Logic)
            const controls = new MapControls('map', [DEFAULT_LAT, DEFAULT_LON], {
                defaultZoom: 18,
                minZoom: 3,  // Unrestricted Zoom Out
                maxZoom: 18  // Max Zoom In
            });
            const map = controls.getMap();

            // --- QUADRANT NAVIGATION HELPER ---
            let lastInputTime = 0; // Debounce tracker
            let blockMouseEvents = false; // Touch Lockout flag

            // --- DEBUG SELECTION HELPERS (Global to DOMContentLoaded) ---
            // Arrays to support highlighting multiple elements (polygon perimeter + lines + circles)
            let selectedLayers = [];
            let originalStyles = [];

            const resetSelection = () => {
                selectedLayers.forEach((layer, i) => {
                    if (layer && originalStyles[i] && typeof layer.setStyle === 'function') {
                        layer.setStyle(originalStyles[i]);
                    }
                });
                selectedLayers = [];
                originalStyles = [];
            };



            // UI BLOCK CHECKER
            const isUIInteraction = (e) => {
                const target = e.target;
                if (target.tagName === 'BUTTON' || target.tagName === 'INPUT' || target.closest('button')) {
                    return true;
                }
                return false;
            };


            // ------------------------------------------------

            // Initialize Layer Groups
            const groupsLayer = L.layerGroup().addTo(map);
            const detailsLayer = L.layerGroup().addTo(map);
            const completedPolygonsLayer = L.layerGroup().addTo(map); // Always visible layer for completed zones

            // Visibility Rules
            // 1. Details (Polygons, Lines, Circles) -> Visible ONLY at Zoom 18
            controls.addVisibilityRule(detailsLayer, 18);

            // 2. Groups (Monolith) -> Visible ONLY at Zoom 18 (Same as details)
            controls.addVisibilityRule(groupsLayer, 18);

            // Custom Marker Icon (Visual)
            // Goal: Purple Circle (Shadow) is centered on the LatLon (Anchor). GIF stands on top.
            const customIcon = L.divIcon({
                className: 'custom-marker',
                html: `
                    <div style="transform: translate(-50%, -50%); position: relative; display: flex; align-items: center; justify-content: center;">
                        <div style="position: absolute; width: 4vh; height: 4vh; background-color: #9900ff; border: 2px solid white; border-radius: 50%; box-shadow: 0 0 15px #9900ff; opacity: 0.8; transform: perspective(500px) rotateX(45deg);"></div>
                        <img src="/B_map_page/components/marker.gif" style="position: relative; z-index: 2; width: 8vh; height: auto; transform: translateY(-25%); bottom: 2vh;">
                    </div>
                `,
                iconSize: null,
                iconAnchor: [0, 0]
            });

            // Create Marker pinned to map
            const userMarker = L.marker([DEFAULT_LAT, DEFAULT_LON], {
                icon: customIcon,
                zIndexOffset: 1000
            }).addTo(map);

            // Reveal Map Logic (Visual Transition)
            const topBarContainer = document.getElementById('top-bar-container');
            const revealMap = () => {
                if (hasRevealed) return;
                hasRevealed = true;
                console.log("DEBUG: Revealing Map...");
                map.invalidateSize();
                loadingGif.style.opacity = '0';
                mapElement.style.opacity = '1';
                topBarContainer.style.opacity = '1';
                setTimeout(() => {
                    loadingGif.style.display = 'none';
                }, 600);
            };

            // Safety Reveal
            /* REMOVED: Safety reveal is dangerous if data is missing. We want STRICT validation.
            setTimeout(() => {
                if (!hasRevealed) {
                    console.warn("DEBUG: Safety Reveal Triggered (Data took too long)");
                    revealMap();
                }
            }, 30000);
            */

            const showError = (msg) => {
                loadingGif.style.display = 'none';
                mapElement.style.display = 'none';
                if (topBarContainer) topBarContainer.style.display = 'none';

                const errorScreen = document.getElementById('error-screen');
                const errorMessage = document.getElementById('error-message');
                const retryBtn = document.getElementById('retry-btn');

                errorScreen.style.display = 'flex';
                errorMessage.innerHTML = msg;

                retryBtn.onclick = () => {
                    window.location.reload();
                };
            };

            // Reusable function to process coordinates (Logic)
            const processCoordinates = (lat, lon, accuracy, label) => {
                console.log(`DEBUG: [Map Page] Processing ${label} Position: ${lat}, ${lon} (Acc: ${accuracy}m)`);

                if (label === 'LOW_ACCURACY' && hasPreciseFix) {
                    console.log("DEBUG: Ignoring Low Accuracy update (Precise already found).");
                    return;
                }

                if (label === 'HIGH_ACCURACY') {
                    hasPreciseFix = true;
                }

                // Use Controls to update position (Enforces map follow rules)
                controls.updateUserPosition(userMarker, lat, lon, isGpsActive);

                // Quality State: 'NONE', 'LOW', 'HIGH'
                // Allows upgrading to High Accuracy if Low was loaded first.
                if (!window.loadedQuality) window.loadedQuality = 'NONE';

                if (isGpsActive) {
                    // Log GPS accuracy status
                    if (accuracy > 200) {
                        console.warn(`GPS: Signal weak (${Math.round(accuracy)}m accuracy)`);
                    } else {
                        console.log(`GPS: Good signal (${Math.round(accuracy)}m accuracy)`);
                    }

                    // Trigger Data Load Logic
                    // 1. If nothing loaded yet -> Load
                    // 2. If 'LOW' loaded and we now have 'HIGH' -> Load (Upgrade)
                    // 3. If 'HIGH' loaded -> Do nothing (Stable)

                    const shouldLoad =
                        (window.loadedQuality === 'NONE') ||
                        (window.loadedQuality === 'LOW' && label === 'HIGH_ACCURACY');

                    if (shouldLoad) {
                        console.log(`GPS: Triggering data load (Quality: ${label}, Previous: ${window.loadedQuality})`);

                        // Update State
                        window.loadedQuality = label === 'HIGH_ACCURACY' ? 'HIGH' : 'LOW';

                        // Force Rebuild - backend handles retry logic
                        loadGameData(lat, lon, true);
                    } else {
                        console.log(`GPS: Skipping data load (Quality: ${label}, Already loaded: ${window.loadedQuality})`);
                    }
                }



                // Background: Send to server
                fetch(`/api/locate?lat=${lat}&lon=${lon}`)
                    .then(res => res.json())
                    .then(data => console.log("DEBUG: Server ack:", data))
                    .catch(err => console.warn("DEBUG: Server sync failed (non-critical):", err));
            };

            const loadGameData = (lat, lon, forceRebuild = false) => {
                console.log("GPS: ========================================");
                console.log(`GPS: Starting polygon generation for (${lat.toFixed(6)}, ${lon.toFixed(6)})`);
                console.log(`GPS: Force rebuild: ${forceRebuild}`);
                console.log("GPS: ========================================");

                // Show Loading GIF and dim map (Visual Transition)
                loadingGif.style.display = 'block';
                loadingGif.style.opacity = '1';
                mapElement.style.opacity = '0.3';
                hasRevealed = false;

                const url = `/api/game_data?lat=${lat}&lon=${lon}&rebuild=${forceRebuild}`;
                console.log(`GPS: Fetching from ${url}`);

                fetch(url)
                    .then(res => {
                        console.log(`GPS: Response status: ${res.status}`);
                        return res.json();
                    })
                    .then(data => {
                        console.log("GPS: Server response received");
                        console.log("GPS: Response keys:", Object.keys(data));

                        // Check for error in response (from retry logic)
                        if (data.error) {
                            console.error(`GPS: ========================================`);
                            console.error(`GPS: SERVER ERROR: ${data.error}`);
                            console.error(`GPS: Message: ${data.message}`);
                            console.error(`GPS: ========================================`);
                            showError(`POLYGON GENERATION FAILED<br><br>${data.message}`);
                            return;
                        }

                        // Validate polygons exist
                        if (!data.polygons || data.polygons.length === 0) {
                            console.error("GPS: No polygons in response (empty data)");
                            showError("CRITICAL ERROR<br><br>No polygons found<br>Map cannot be generated");
                            return;
                        }

                        console.log(`GPS: ========================================`);
                        console.log(`GPS: SUCCESS! ${data.polygons.length} polygons received`);
                        console.log(`GPS: Blue circles: ${data.blue_circles?.length || 0}`);
                        console.log(`GPS: White lines: ${data.white_lines?.length || 0}`);
                        console.log(`GPS: Green circles: ${data.green_circles?.length || 0}`);
                        console.log(`GPS: ========================================`);

                        renderGameElements(data);
                        revealMap();
                    })
                    .catch(err => {
                        console.error("GPS: ========================================");
                        console.error("GPS: NETWORK ERROR:", err);
                        console.error("GPS: ========================================");
                        showError("CONNECTION ERROR<br><br>Server failed to respond<br>Please try again");
                    });
            };


            const renderGameElements = (data) => {

                console.log("DEBUG: Starting Render with Progress Tracking...");

                groupsLayer.clearLayers();
                detailsLayer.clearLayers();

                // STRICT VALIDATION
                if (!data || !data.polygons || data.polygons.length === 0) {
                    console.error("CRITICAL: No polygons found in game data.");
                    showError("CRITICAL ERROR:<br>No polygons found.<br>Map cannot be generated.");
                    return;
                }

                // --- 0. DEEP ID INTEGRATION & GLOBAL STORAGE ---
                window.allItems = new Map();
                const lineIdMap = new Map(); // Old ID (number) -> New UID (string)

                const generateUID = (prefix) => {
                    return `${prefix}_${Math.random().toString(36).substr(2, 9)}`;
                };

                // A. Process White Lines (Dependencies for Polygons/Circles)
                if (data.white_lines) {
                    data.white_lines.forEach(line => {
                        const originalId = line.id;
                        line.uid = generateUID('WHITE_LINE');
                        line.id = line.uid; // Swap ID for consistency in app logic
                        line.original_id = originalId; // Keep for reference if needed

                        if (originalId !== undefined) {
                            lineIdMap.set(Number(originalId), line.uid);
                            lineIdMap.set(String(originalId), line.uid); // String safety
                        }

                        window.allItems.set(line.uid, line);
                    });
                }

                // B. Process Green Circles (Depend on Lines)
                if (data.green_circles) {
                    data.green_circles.forEach(circle => {
                        circle.uid = generateUID('GREEN_CIRCLE');
                        circle.id = circle.uid;

                        // Update Reference (Foreign Key)
                        if (circle.line_id !== undefined) {
                            const newRef = lineIdMap.get(circle.line_id);
                            if (newRef) {
                                circle.line_id = newRef;
                            } else {
                                console.warn(`Ref Error: Green Circle ${circle.uid} points to unknown line ${circle.line_id}`);
                            }
                        }

                        window.allItems.set(circle.uid, circle);
                    });
                }

                // C. Process Polygons (Depend on Lines)
                if (data.polygons) {
                    data.polygons.forEach(poly => {
                        // UNIFIED ID SCHEME: 
                        // Generate Random UID and use it as the ONLY valid ID.
                        // This ensures:
                        // 1. Debug UI shows "POLYGON_..."
                        // 2. Logic works (using string ID)
                        // 3. Persistence resets on reload (since ID changes)

                        poly.uid = generateUID('POLYGON');
                        poly.id = poly.uid; // UNIFIED.

                        // Map Wrapper: Update boundary references
                        if (poly.boundary_white_lines) {
                            poly.boundary_white_lines = poly.boundary_white_lines.map(oldId => {
                                const newId = lineIdMap.get(oldId);
                                return newId || oldId;
                            });
                        }

                        window.allItems.set(poly.uid, poly);
                    });
                }

                // D. Process Blue Circles
                if (data.blue_circles) {
                    data.blue_circles.forEach(circle => {
                        circle.uid = generateUID('BLUE_CIRCLE');
                        circle.id = circle.uid;
                        window.allItems.set(circle.uid, circle);
                    });
                }

                // E. Count Blue Circles per Polygon (match coords)
                if (data.polygons && data.blue_circles) {
                    // Build a Set of blue circle coordinates for fast lookup
                    const blueCircleCoords = new Set(
                        data.blue_circles.map(bc => `${bc.lat.toFixed(7)},${bc.lon.toFixed(7)}`)
                    );

                    data.polygons.forEach(poly => {
                        let count = 0;
                        if (poly.coords) {
                            // DEDUPLICATE polygon coords first (closing vertex = first vertex)
                            const uniquePolyCoords = new Set(
                                poly.coords.map(c => `${c[0].toFixed(7)},${c[1].toFixed(7)}`)
                            );
                            // Count how many unique polygon vertices have a blue circle
                            uniquePolyCoords.forEach(coordKey => {
                                if (blueCircleCoords.has(coordKey)) {
                                    count++;
                                }
                            });
                        }
                        poly.blue_circles_count = count;
                    });
                }

                // F. Enrich White Lines with related elements
                if (data.white_lines && data.blue_circles && data.green_circles) {
                    // Build coord -> blue circle UID map
                    const blueByCoord = new Map();
                    data.blue_circles.forEach(bc => {
                        const key = `${bc.lat.toFixed(7)},${bc.lon.toFixed(7)}`;
                        blueByCoord.set(key, bc.uid);
                    });

                    // Build lineId -> green circles list
                    const greenByLine = new Map();
                    data.green_circles.forEach(gc => {
                        if (!greenByLine.has(gc.line_id)) greenByLine.set(gc.line_id, []);
                        greenByLine.get(gc.line_id).push(gc.uid);
                    });

                    data.white_lines.forEach(line => {
                        // Find endpoint blue circles
                        const startKey = `${line.start[0].toFixed(7)},${line.start[1].toFixed(7)}`;
                        const endKey = `${line.end[0].toFixed(7)},${line.end[1].toFixed(7)}`;

                        line.endpoint_blue_circles = [];
                        if (blueByCoord.has(startKey)) line.endpoint_blue_circles.push(blueByCoord.get(startKey));
                        if (blueByCoord.has(endKey)) line.endpoint_blue_circles.push(blueByCoord.get(endKey));

                        // Find green circles on this line
                        line.green_circles_uids = greenByLine.get(line.uid) || [];
                        line.green_circles_count = line.green_circles_uids.length;
                        line.total_circles = line.endpoint_blue_circles.length + line.green_circles_count;
                    });
                }


                // STATE STORAGE (Closure Scope)
                const polygonState = new Map(); // ID -> { current: 0, total: N, polyLayer, labelLayer, lineIds }
                const circleToPolyMap = new Map(); // "lat,lon" -> [ID, ID...]
                const lineLayerMap = new Map(); // "lineID" -> Layer

                // Helper to map a circle coord to polygons
                const mapCircleToPolys = (lat, lon, polyList, whiteLineId = -1) => {
                    const key = `${lat.toFixed(6)},${lon.toFixed(6)}`;

                    if (!circleToPolyMap.has(key)) circleToPolyMap.set(key, []);
                    const list = circleToPolyMap.get(key);

                    polyList.forEach(poly => {
                        let isRelevant = false;
                        // Check Green Stickiness (Line ID)
                        // Note: poly.boundary_white_lines and whiteLineId are now UIDs (Strings)
                        if (whiteLineId !== -1 && poly.boundary_white_lines && poly.boundary_white_lines.includes(whiteLineId)) {
                            isRelevant = true;
                        }
                        // Check Blue Stickiness (Vertex Match)
                        else if (whiteLineId === -1) {
                            // This is a blue circle. Check if it matches a vertex of the polygon.
                            const isVertex = poly.coords.some(c => Math.abs(c[0] - lat) < 0.00001 && Math.abs(c[1] - lon) < 0.00001);
                            if (isVertex) isRelevant = true;
                        }

                        if (isRelevant) {
                            if (!list.includes(poly.id)) list.push(poly.id);
                        }
                    });
                };

                // 1. Groups
                if (data.groups) {
                    data.groups.forEach(group => {
                        L.polygon(group.coords, {
                            color: '#333', stroke: false, fillColor: '#222', fillOpacity: 0.3, weight: 0
                        }).addTo(groupsLayer);
                    });
                }

                // SHARED DEBUG LOGIC
                // resetSelection is now defined in parent scope

                // Lazy references for maps (filled after circles/lines created)
                let _lineLayerMap = null;
                let _circleLayerMap = null;
                let _blueCircleLayerMap = null; // Extra map for blue circles by coord key
                let _greenCirclesByLine = null; // lineId -> [layer, layer, ...]

                const attachDebugClick = (layer, data, type) => {
                    layer.on('click', (e) => {
                        if (!isDebugActive) return;
                        L.DomEvent.stopPropagation(e);

                        // Highlight Logic (Safely)
                        resetSelection();

                        // Redirect to visual proxy if available (for Hit Layers)
                        const targetLayer = layer.visualSibling || layer;

                        // POLYGON LABEL SPECIAL HANDLING
                        if (type === 'Polygon Label' && data.boundary_white_lines) {
                            // 1. Highlight Polygon Perimeter (border only, no fill change)
                            if (typeof targetLayer.setStyle === 'function') {
                                originalStyles.push({
                                    color: targetLayer.options.color,
                                    weight: targetLayer.options.weight
                                });
                                selectedLayers.push(targetLayer);
                                targetLayer.setStyle({ color: 'red', weight: 3 });
                            }

                            // 2. Highlight White Lines
                            if (_lineLayerMap) {
                                data.boundary_white_lines.forEach(lineId => {
                                    const lineLayers = _lineLayerMap.get(String(lineId));
                                    if (lineLayers && lineLayers.visual) {
                                        originalStyles.push({
                                            color: lineLayers.visual.options.color,
                                            weight: lineLayers.visual.options.weight,
                                            dashArray: lineLayers.visual.options.dashArray,
                                            opacity: lineLayers.visual.options.opacity
                                        });
                                        selectedLayers.push(lineLayers.visual);
                                        lineLayers.visual.setStyle({ color: 'red', weight: 3, dashArray: null, opacity: 1 });
                                    }
                                });
                            }

                            // 3. Highlight Green Circles on these lines
                            if (_greenCirclesByLine) {
                                data.boundary_white_lines.forEach(lineId => {
                                    const circles = _greenCirclesByLine.get(String(lineId)); // use String ID
                                    if (circles) {
                                        circles.forEach(circleLayer => {
                                            if (typeof circleLayer.setStyle === 'function') {
                                                originalStyles.push({
                                                    color: circleLayer.options.color,
                                                    weight: circleLayer.options.weight || 1,
                                                    fillColor: circleLayer.options.fillColor,
                                                    fillOpacity: circleLayer.options.fillOpacity
                                                });
                                                selectedLayers.push(circleLayer);
                                                circleLayer.setStyle({ color: 'red', weight: 3 });
                                            }
                                        });
                                    }
                                });
                            }

                            // 4. Highlight Blue Circles (vertices) on polygon coords
                            if (_blueCircleLayerMap && data.coords) {
                                data.coords.forEach(coord => {
                                    const key = `${coord[0].toFixed(6)},${coord[1].toFixed(6)}`;
                                    const blueCircle = _blueCircleLayerMap.get(key);
                                    if (blueCircle && typeof blueCircle.setStyle === 'function') {
                                        // Check if not already selected
                                        if (!selectedLayers.includes(blueCircle)) {
                                            originalStyles.push({
                                                color: blueCircle.options.color,
                                                weight: blueCircle.options.weight,
                                                fillColor: blueCircle.options.fillColor,
                                                fillOpacity: blueCircle.options.fillOpacity
                                            });
                                            selectedLayers.push(blueCircle);
                                            blueCircle.setStyle({ color: 'red', weight: 4 });
                                        }
                                    }
                                });
                            }

                            // 5. Highlight the Label Itself (The clicked element)
                            // Note: We polyfilled setStyle on the label marker.
                            if (layer && typeof layer.setStyle === 'function' && !selectedLayers.includes(layer)) {
                                originalStyles.push({ color: 'original' }); // Mock style for restore
                                selectedLayers.push(layer);
                                layer.setStyle({ color: 'red', weight: 3 });
                            }
                        }
                        // WHITE LINE SPECIAL HANDLING
                        else if (type === 'White Line' && data.uid) {
                            // 1. Highlight the Line itself
                            if (_lineLayerMap) {
                                const lineComposite = _lineLayerMap.get(String(data.uid));
                                if (lineComposite && lineComposite.visual) {
                                    originalStyles.push({
                                        color: lineComposite.visual.options.color,
                                        weight: lineComposite.visual.options.weight,
                                        dashArray: lineComposite.visual.options.dashArray,
                                        opacity: lineComposite.visual.options.opacity
                                    });
                                    selectedLayers.push(lineComposite.visual);
                                    lineComposite.visual.setStyle({ color: 'red', weight: 4, dashArray: null, opacity: 1 });
                                }
                            }

                            // 2. Highlight Blue Circles at endpoints
                            if (_blueCircleLayerMap && data.start && data.end) {
                                const startKey = `${data.start[0].toFixed(6)},${data.start[1].toFixed(6)}`;
                                const endKey = `${data.end[0].toFixed(6)},${data.end[1].toFixed(6)}`;

                                [startKey, endKey].forEach(key => {
                                    const blueCircle = _blueCircleLayerMap.get(key);
                                    if (blueCircle && typeof blueCircle.setStyle === 'function') {
                                        if (!selectedLayers.includes(blueCircle)) {
                                            originalStyles.push({
                                                color: blueCircle.options.color,
                                                weight: blueCircle.options.weight,
                                                fillColor: blueCircle.options.fillColor,
                                                fillOpacity: blueCircle.options.fillOpacity
                                            });
                                            selectedLayers.push(blueCircle);
                                            blueCircle.setStyle({ color: 'red', weight: 4 });
                                        }
                                    }
                                });
                            }

                            // 3. Highlight Green Circles on this line
                            if (_greenCirclesByLine) {
                                const greenCircles = _greenCirclesByLine.get(String(data.uid));
                                if (greenCircles) {
                                    greenCircles.forEach(circleLayer => {
                                        if (typeof circleLayer.setStyle === 'function' && !selectedLayers.includes(circleLayer)) {
                                            originalStyles.push({
                                                color: circleLayer.options.color,
                                                weight: circleLayer.options.weight || 1,
                                                fillColor: circleLayer.options.fillColor,
                                                fillOpacity: circleLayer.options.fillOpacity
                                            });
                                            selectedLayers.push(circleLayer);
                                            circleLayer.setStyle({ color: 'red', weight: 3 });
                                        }
                                    });
                                }
                            }
                        }
                        // STANDARD HANDLING for other types
                        else if (typeof targetLayer.setStyle === 'function') {
                            if (type.includes('Circle')) {
                                originalStyles.push({
                                    color: targetLayer.options.color,
                                    weight: targetLayer.options.weight,
                                    fillColor: targetLayer.options.fillColor,
                                    fillOpacity: targetLayer.options.fillOpacity
                                });
                                selectedLayers.push(targetLayer);
                                targetLayer.setStyle({ color: 'red', weight: 4, opacity: 1 });
                            } else if (type.includes('Line')) {
                                originalStyles.push({
                                    color: targetLayer.options.color,
                                    dashArray: targetLayer.options.dashArray,
                                    weight: targetLayer.options.weight,
                                    opacity: targetLayer.options.opacity
                                });
                                selectedLayers.push(targetLayer);
                                targetLayer.setStyle({ color: 'red', dashArray: null, weight: 4, opacity: 1 });
                            } else if (type.includes('Polygon')) {
                                originalStyles.push({
                                    color: targetLayer.options.color,
                                    weight: targetLayer.options.weight,
                                    fillOpacity: targetLayer.options.fillOpacity
                                });
                                selectedLayers.push(targetLayer);
                                targetLayer.setStyle({ color: 'red', weight: 3 });
                            }
                        }

                        // PREPARE DISPLAY DATA
                        // Fix for circular ref if any, and ensure UID is top
                        const debugData = { ...data };
                        const contentObj = { ...data };
                        // Remove large arrays for display if needed, but user wants info.
                        // Ensure UID is visible if property name is different
                        if (data.uid) debugData.uid = data.uid;

                        const prettyJSON = JSON.stringify(contentObj, null, 2);
                        const idDisplay = contentObj.uid ? `<b>ID:</b> ${contentObj.uid}<br>` : (contentObj.id ? `<b>ID:</b> ${contentObj.id}<br>` : '');

                        // CALCULATE STATS FOR POLYGONS
                        let statsHtml = '';
                        if (type === 'Polygon Label' || type === 'Polygon') {
                            // Use actual blue_circles_count (matched from data)
                            const blueCount = data.blue_circles_count || 0;
                            const whiteLinesCount = data.boundary_white_lines ? data.boundary_white_lines.length : 0;
                            const totalPoints = data.total_points || 0;
                            const greenCount = Math.max(0, totalPoints - blueCount); // Green = Total - Blue

                            statsHtml = `
                                <div style="margin-bottom:8px; padding:4px; background:#e6f7ff; border-radius:4px; border:1px solid #91d5ff;">
                                    <b>Polygon Stats:</b><br>
                                    üîµ Blue Circles: <b>${blueCount}</b><br>
                                    ‚ö™ White Lines: <b>${whiteLinesCount}</b><br>
                                    üü¢ Green Circles: <b>${greenCount}</b><br>
                                    --------------------------<br>
                                    ‚àë Total Circles: <b>${totalPoints}</b>
                                </div>
                            `;
                        }
                        // STATS FOR WHITE LINES
                        else if (type === 'White Line') {
                            const blueEndpoints = data.endpoint_blue_circles ? data.endpoint_blue_circles.length : 0;
                            const greenCount = data.green_circles_count || 0;
                            const totalCircles = data.total_circles || (blueEndpoints + greenCount);
                            const lineLength = data.length ? data.length.toFixed(2) : '?';

                            statsHtml = `
                                <div style="margin-bottom:8px; padding:4px; background:#fff7e6; border-radius:4px; border:1px solid #ffd591;">
                                    <b>Line Stats:</b><br>
                                    üìè Length: <b>${lineLength}m</b><br>
                                    üîµ Blue Endpoints: <b>${blueEndpoints}</b><br>
                                    üü¢ Green Circles: <b>${greenCount}</b><br>
                                    --------------------------<br>
                                    ‚àë Total Circles: <b>${totalCircles}</b>
                                </div>
                            `;
                        }

                        const container = document.createElement('div');
                        container.innerHTML = `
                            <div style="font-size: 11px; line-height: 1.2; color: #333;">
                                ${idDisplay}
                                <b>Type:</b> ${type}<br>
                                ${statsHtml}
                                <details>
                                    <summary style="cursor:pointer; color:#0066cc; margin:4px 0;">Show Raw Data</summary>
                                    <pre style="background:#f0f0f0; padding:4px; border-radius:4px; max-height:150px; overflow:auto; margin:4px 0;">${prettyJSON}</pre>
                                </details>
                                <button style="width:100%; cursor:pointer; padding:4px;">Copy Data</button>
                            </div>
                        `;

                        const btn = container.querySelector('button');
                        btn.onclick = () => {
                            navigator.clipboard.writeText(prettyJSON).then(() => {
                                btn.innerText = "Copied!";
                                setTimeout(() => btn.innerText = "Copy Data", 2000);
                            });
                        };

                        L.popup({ minWidth: 200 })
                            .setLatLng(e.latlng)
                            .setContent(container)
                            .openOn(map);
                    });
                };

                // Helper to set lazy references after maps are created
                const setDebugMaps = (lineMap, circleMap, blueMap, greenByLine) => {
                    _lineLayerMap = lineMap;
                    _circleLayerMap = circleMap;
                    _blueCircleLayerMap = blueMap;
                    _greenCirclesByLine = greenByLine;
                };

                // Map click to clear selection
                map.on('click', () => {
                    if (isDebugActive) {
                        resetSelection();
                        map.closePopup();
                    }
                });

                // 2. Polygons (Init State)
                const localPolys = data.polygons || [];
                localPolys.forEach(poly => {
                    // Create Visual
                    const pLayer = L.polygon(poly.coords, {
                        color: 'purple', fillColor: 'purple', fillOpacity: 0.1, weight: 0
                    }).addTo(detailsLayer);

                    // attachDebugClick(pLayer, poly, 'Polygon'); // Removed per user request

                    const pLabel = L.marker([poly.center[0], poly.center[1]], {
                        icon: L.divIcon({
                            className: 'poly-label',
                            html: `<div style="background:white; border-radius:50%; width:30px; height:30px; text-align:center; line-height:30px; color:black; font-size:10px; opacity: 0.8; font-weight:bold; pointer-events: auto;">0%</div>`,
                            iconSize: [30, 30],
                            iconAnchor: [15, 15]
                        }),
                        interactive: true // Ensure it captures clicks
                    }).addTo(detailsLayer);

                    // LABEL UID Creation (Specific object for debug)
                    const labelDebugData = {
                        uid: generateUID('WHITE_CIRCLE'),
                        parent_polygon_uid: poly.uid,
                        boundary_white_lines: poly.boundary_white_lines,
                        center: poly.center,
                        coords: poly.coords,
                        total_points: poly.total_points,
                        blue_circles_count: poly.blue_circles_count || 0
                    };
                    window.allItems.set(labelDebugData.uid, labelDebugData);

                    // Link Label to Polygon for Debug Highlighting
                    pLabel.visualSibling = pLayer;

                    // POLYFILL: Add setStyle to Marker (DivIcon) to support Debug Highlighting
                    pLabel.setStyle = function (style) {
                        const icon = this.options.icon;
                        let html = icon.options.html;

                        // Parse Style request
                        if (style.color === 'red') {
                            // Add Border
                            if (!html.includes('border: 3px solid red')) {
                                // Add border to the inner div.
                                // Note: The inner div has existing style. We append.
                                // Box-sizing is border-box, so adding border won't break layout.
                                html = html.replace('background:white;', 'background:white; border: 3px solid red;');
                            }
                        } else {
                            // Restore / Remove Border
                            html = html.replace('border: 3px solid red;', '');
                        }

                        // Update Icon
                        if (html !== icon.options.html) {
                            icon.options.html = html;
                            this.setIcon(icon);
                        }
                    };

                    // Attach debug click to the Label as well (shows Label + Polygon Data)
                    attachDebugClick(pLabel, labelDebugData, 'Polygon Label');

                    const savedCount = parseInt(localStorage.getItem(`poly_${poly.id}`) || '0');

                    const pState = {
                        id: poly.id, // Now uses RANDOM UID
                        uid: poly.uid,
                        current: savedCount, // Will usually be 0 unless random check luck
                        total: poly.total_points,
                        layer: pLayer,
                        label: pLabel,
                        lines: poly.boundary_white_lines // New UIDs
                    };


                    polygonState.set(poly.id, pState);

                    // Immediate Completion Check (Restoration)
                    // Immediate Completion Check (Restoration)
                    if (pState.current >= pState.total) {
                        console.log(`DEBUG: Restoring Completed Polygon ${poly.id} to Persistent Layer`);
                        // Move to Persistent Layer immediately
                        if (detailsLayer.hasLayer(pLayer)) detailsLayer.removeLayer(pLayer);
                        completedPolygonsLayer.addLayer(pLayer);

                        pLayer.setStyle({
                            color: '#00ff00',
                            fillColor: '#00ff00',
                            fillOpacity: 0.4
                        });
                        if (pLabel) pLabel.remove();
                        pState.label = null;

                        // Hide lines (Deferred until lines are created? No, lines created later. 
                        // Wait, lines are created AFTER polygons in this loop order?
                        // No, Polygons are step 2, White Lines are Step 3.
                        // We need to handle line hiding in Step 3 or a post-init check.)
                    }
                    else {
                        // Update Label Text if partially complete
                        const pct = Math.floor((pState.current / pState.total) * 100);
                        const icon = pLabel.options.icon;
                        icon.options.html = icon.options.html.replace(/>\d+%</, `>${pct}%<`);
                        pLabel.setIcon(icon);
                    }
                });

                // 3. White Lines (Index)
                if (data.white_lines) {
                    controls.setSnapLines(data.white_lines);
                    data.white_lines.forEach(line => {
                        // Visual Layer (Thin, Dashed, Non-Interactive)
                        const visual = L.polyline(line.path, {
                            color: 'white', weight: 2, dashArray: '5, 5', interactive: false
                        }).addTo(detailsLayer);

                        // Hit Layer (Thick, Solid, Transparent, Interactive)
                        const hit = L.polyline(line.path, {
                            color: 'white', weight: 15, opacity: 0, interactive: true
                        }).addTo(detailsLayer);

                        attachDebugClick(hit, line, 'White Line');

                        // Composite Proxy for Logic Handling
                        const composite = {
                            visual: visual,
                            hit: hit,
                            setStyle: function (style) {
                                this.visual.setStyle(style);
                                // If hiding, disable hit layer interaction
                                if (style.opacity === 0) {
                                    this.hit.setStyle({ interactive: false });
                                } else {
                                    // Restore if showing
                                    this.hit.setStyle({ interactive: true });
                                }
                            }
                        };

                        if (line.id !== undefined) {
                            lineLayerMap.set(String(line.id), composite);
                        }
                    });
                    const currentPos = userMarker.getLatLng();
                    controls.updateUserPosition(userMarker, currentPos.lat, currentPos.lng, isGpsActive);

                    // POST-INIT: Hide lines for restored completed polygons
                    // Now that lines are created and mapped, we can hiding them.
                    polygonState.forEach(state => {
                        if (state.current >= state.total && state.lines) {
                            state.lines.forEach(lid => {
                                const lineLayer = lineLayerMap.get(String(lid));
                                if (lineLayer) {
                                    lineLayer.setStyle({ opacity: 0, fillOpacity: 0 });
                                }
                            });
                        }
                    });
                }

                // 4. Circles (Rendering + Mapping)
                // Track Layers for Hiding Logic
                const circleLayerMap = new Map();
                const blueCircleLayerMap = new Map(); // coord key -> blue circle layer
                const greenCirclesByLine = new Map(); // lineId -> [visual layers]

                const addToMap = (lat, lon, layer, type, lineId = -1) => {
                    const key = `${lat.toFixed(6)},${lon.toFixed(6)}`;
                    circleLayerMap.set(key, layer);

                    // Map to Polygons
                    mapCircleToPolys(lat, lon, localPolys, lineId);
                };

                // Shared Debug Click Handler (Removed from here, moved to top)


                if (data.blue_circles) {
                    data.blue_circles.forEach(circle => {
                        const marker = L.circleMarker([circle.lat, circle.lon], {
                            radius: 8, color: 'blue', fillColor: '#00ccff', fillOpacity: 0.8
                        }).addTo(detailsLayer);
                        marker.bindTooltip(String(circle.connections), { permanent: true, direction: 'center', className: 'circle-label' });
                        // Blue circles are large enough, no composite needed yet unless requested
                        addToMap(circle.lat, circle.lon, marker, 'blue');
                        attachDebugClick(marker, circle, 'Blue Circle');

                        // Track for polygon debug highlighting
                        const key = `${circle.lat.toFixed(6)},${circle.lon.toFixed(6)}`;
                        blueCircleLayerMap.set(key, marker);
                    });
                }

                if (data.green_circles) {
                    data.green_circles.forEach(circle => {
                        // Visual (Small)
                        const visual = L.circleMarker([circle.lat, circle.lon], {
                            radius: 4, color: 'green', fillColor: '#00ff00', fillOpacity: 1, interactive: false
                        }).addTo(detailsLayer);

                        // Hit (Large)
                        const hit = L.circleMarker([circle.lat, circle.lon], {
                            radius: 12, stroke: false, fillOpacity: 0, interactive: true
                        }).addTo(detailsLayer);

                        hit.visualSibling = visual; // Helper for Debug Highlighting

                        attachDebugClick(hit, circle, 'Green Circle');

                        // Composite Proxy
                        const composite = {
                            visual: visual,
                            hit: hit,
                            get options() { return this.visual.options; }, // Dynamic Getter to ensure live state Check
                            setStyle: function (style) {
                                this.visual.setStyle(style);
                                // If hiding, disable hit layer
                                if (style.opacity === 0) {
                                    this.hit.setStyle({ interactive: false });
                                } else {
                                    this.hit.setStyle({ interactive: true });
                                }
                            },
                            getTooltip: function () { return this.visual.getTooltip(); }, // Pass through (Fix Context)
                            unbindTooltip: function () { return this.visual.unbindTooltip(); }
                        };

                        addToMap(circle.lat, circle.lon, composite, 'green', circle.line_id);

                        // Track for polygon debug highlighting (by line_id)
                        if (circle.line_id !== undefined) {
                            if (!greenCirclesByLine.has(circle.line_id)) {
                                greenCirclesByLine.set(circle.line_id, []);
                            }
                            greenCirclesByLine.get(circle.line_id).push(visual);
                        }
                    });
                }

                // Set debug maps for polygon highlighting feature
                setDebugMaps(lineLayerMap, circleLayerMap, blueCircleLayerMap, greenCirclesByLine);

                // Red Lines / Street Names removed. 
                // We now use the Google Text Overlay in map_controls.js

                // Setup Hiding Logic with Progress Tracking
                controls.checkVisibility();
                const currentZoom = map.getZoom();
                console.log(`GPS: Visibility check complete. Current zoom: ${currentZoom}. detailsLayer has ${detailsLayer.getLayers().length} layers.`);
                console.log(`GPS: Polygons visible at zoom >= 18. Current: ${currentZoom >= 18 ? 'YES' : 'NO'}`);

                controls.updateGraph(data.green_circles, data.blue_circles, data.white_lines);
                setupProgressHiding(circleLayerMap, circleToPolyMap, polygonState, lineLayerMap);
            };

            const setupProgressHiding = (layerMap, circleMap, polyState, lineMap) => {
                const checkAndHide = () => {
                    const pos = userMarker.getLatLng();
                    const key = `${pos.lat.toFixed(6)},${pos.lng.toFixed(6)}`;

                    const target = layerMap.get(key);
                    if (target) {
                        // Check if already hidden
                        if (target.options.opacity !== 0) {
                            // HIDE IT
                            target.setStyle({ opacity: 0, fillOpacity: 0 });

                            // Safe Tooltip Check (Must be a function and truthy)
                            if (typeof target.getTooltip === 'function' && target.getTooltip()) {
                                target.unbindTooltip(); // Permanently remove label
                            }

                            // UPDATE PROGRESS
                            const relevantPolys = circleMap.get(key);
                            if (relevantPolys) {
                                relevantPolys.forEach(pid => {
                                    const state = polyState.get(pid);
                                    if (state && state.current < state.total) {
                                        state.current++;
                                        updatePolygonVisuals(state, lineMap);
                                    }
                                });
                            }
                        }
                    }
                };

                // Remove old handler if exists (not strictly needed since we rebuild, but good practice)
                if (userMarker._hideHandler) {
                    userMarker.off('move', userMarker._hideHandler);
                }

                // Initial check
                checkAndHide();

                // Bind
                userMarker._hideHandler = checkAndHide;
                userMarker.on('move', checkAndHide);
            };

            const updatePolygonVisuals = (state, lineMap) => {
                const pct = Math.floor((state.current / state.total) * 100);

                // Update Label
                if (state.label) {
                    const icon = state.label.options.icon;
                    // Safe update of HTML
                    icon.options.html = icon.options.html.replace(/>\d+%</, `>${pct}%<`);
                    state.label.setIcon(icon);
                }

                // SAVE PROGRESS
                // We need the ID. We don't have ID in 'state' object directly? 
                // polygonState is Map<ID, State>. 
                // 'state' is the value. We need 'key' or we add ID to state.
                // Looking at init: ID is poly.id. 
                // We need to add ID to state object to save it easily here.
                // OR find key by value (slow).
                // Let's assume we can get it or just pass it.
                // updatePolygonVisuals is called with (state, lineMap).
                // Let's just find the ID in the loop calling this: `relevantPolys.forEach(pid => ...)`

                // Wait, I can't modify the call signature easily without checking setupProgressHiding.
                // Let's add ID to the state object in the init step first.
                // BUT I already sent the init step replacement!
                // FIX: I will depend on the NEXT tool call to add ID to state, then this one.
                // Actually, I can use the `polyState` map iterator to find it? No.

                // BETTER: Modify `setupProgressHiding` to pass the ID.
                // Only `setupProgressHiding` calls this.
                // Let's check `setupProgressHiding` implementation.
                // It has `relevantPolys.forEach(pid => { const state = polyState.get(pid); ... })`
                // So I have `pid` there!
                // I should pass `pid` to `updatePolygonVisuals`.

                // REFRESH: I will update `updatePolygonVisuals` signature to `(pid, state, lineMap)`.

                // SAVE PROGRESS
                if (state.id) {
                    localStorage.setItem(`poly_${state.id}`, state.current);
                }

                // Check Completion
                if (state.current >= state.total) {
                    console.log("DEBUG: Polygon Completed! Moving to Persistent Layer.");

                    // 1. Turn Green & Move to Persistent Layer
                    // Remove from detailsLayer (which hides on zoom out)
                    // Ensure it is explicitly removed from the hiding detailsLayer
                    if (detailsLayer.hasLayer(state.layer)) {
                        detailsLayer.removeLayer(state.layer);
                    } else {
                        state.layer.remove();
                    }

                    // Add to completedLayer (visible everywhere)
                    if (!completedPolygonsLayer.hasLayer(state.layer)) {
                        completedPolygonsLayer.addLayer(state.layer);
                    }

                    state.layer.setStyle({
                        color: '#00ff00',
                        fillColor: '#00ff00',
                        fillOpacity: 0.4
                    });

                    // 2. Remove Label
                    if (state.label) {
                        state.label.remove();
                        state.label = null;
                    }

                    // 3. Hide White Lines
                    if (state.lines) {
                        state.lines.forEach(lid => {
                            const lineLayer = lineMap.get(String(lid));
                            if (lineLayer) {
                                lineLayer.setStyle({ opacity: 0, fillOpacity: 0 });
                                // Note: This might hide a line shared with an INCOMPLETE polygon. 
                                // User requested: "when in perimeter of polygon no visible circles left... disappear white lines in this perimeter"
                                // This implies strict removal.
                            }
                        });
                    }
                }
            };

            // Listen for keyboard navigation requests
            document.addEventListener('map-move-request', (e) => {
                const { lat, lon } = e.detail;
                // Move marker directly without re-snapping (we assume the graph node is already snapped/valid)
                // But utilizing updateUserPosition ensures consistency if we want it.
                // However, updateUserPosition calls getSnappedPosition AGAIN.
                // If graph nodes are accurate, this is fine.
                controls.updateUserPosition(userMarker, lat, lon, isGpsActive);

                // Ensure map centers on it
                map.panTo([lat, lon]);
            });

            const startLocationWatch = () => {
                console.log("DEBUG: [Map Page] Requesting browser geolocation (permission should be granted)...");

                if (!("geolocation" in navigator)) {
                    alert("Geolocation not supported by this browser.");
                    revealMap();
                    return;
                }

                hasPreciseFix = false;

                // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ, –≤—ã–¥–∞–Ω–Ω–æ–µ –Ω–∞ home page
                navigator.geolocation.getCurrentPosition(
                    (pos) => {
                        console.log("DEBUG: GPS Position received:", pos.coords);
                        processCoordinates(pos.coords.latitude, pos.coords.longitude, pos.coords.accuracy, 'HIGH_ACCURACY');
                    },
                    (err) => {
                        console.error("DEBUG: Geolocation failed:", err);
                        if (err.code === 1) {
                            alert("Location access denied. Please grant permission.");
                        } else if (err.code === 3) {
                            alert("Location timeout. Please try again.");
                        } else {
                            alert("Unable to get location: " + err.message);
                        }
                        revealMap();
                    },
                    { enableHighAccuracy: true, timeout: 15000, maximumAge: 0 }
                );
            };

            // Navigation / Top Bar Logic 
            fetch('/B_map_page/components/top_bar.html')
                .then(response => response.text())
                .then(html => {
                    document.getElementById('top-bar-container').innerHTML = html;
                    initTopBarEvents();
                })
                .catch(err => console.error('Error loading top bar:', err));

            // Initial Auto-Start
            isGpsActive = false;
            loadGameData(DEFAULT_LAT, DEFAULT_LON);

            const initTopBarEvents = () => {
                const gpsBtn = document.getElementById('gps-btn');
                const debugBtn = document.getElementById('debug-btn');
                const menuBtn = document.getElementById('menu-btn');
                const topBar = document.getElementById('top-bar');

                const closeMenu = () => {
                    if (topBar && topBar.classList.contains('expanded')) {
                        topBar.classList.remove('expanded');
                    }
                };

                // Get .black-square for background change
                const blackSquare = document.querySelector('.black-square');

                if (debugBtn) {
                    debugBtn.addEventListener('click', () => {
                        isDebugActive = !isDebugActive;
                        if (isDebugActive) {
                            console.log("DEBUG: Debug Mode ENABLED");
                            debugBtn.classList.add('active');
                            // Add Class to Body for global styling
                            document.body.classList.add('debug-mode');

                        } else {
                            console.log("DEBUG: Debug Mode DISABLED");
                            debugBtn.classList.remove('active');
                            // Remove Class
                            document.body.classList.remove('debug-mode');

                            map.closePopup();
                            resetSelection();
                        }
                    });
                }

                if (gpsBtn) {
                    gpsBtn.addEventListener('click', () => {
                        isGpsActive = !isGpsActive;

                        if (isGpsActive) {
                            console.log("DEBUG: GPS Toggled ON");
                            gpsBtn.classList.add('active');

                            // Show loading GIF immediately
                            loadingGif.style.display = 'block';
                            loadingGif.style.opacity = '1';
                            mapElement.style.opacity = '0.3';
                            topBarContainer.style.opacity = '0';
                            hasRevealed = false;

                            // Reset State on fresh activation
                            window.loadedQuality = 'NONE';
                            startLocationWatch();
                        } else {
                            console.log("DEBUG: GPS Toggled OFF. Reverting to default.");
                            gpsBtn.classList.remove('active');
                            hasPreciseFix = false;
                            window.loadedQuality = 'NONE';

                            // Use Controls to reset view
                            controls.resetView(DEFAULT_LAT, DEFAULT_LON);
                            userMarker.setLatLng([DEFAULT_LAT, DEFAULT_LON]);

                            // Trigger load to show animation and refresh data
                            loadGameData(DEFAULT_LAT, DEFAULT_LON, false);
                        }
                    });
                }

                if (menuBtn && topBar) {
                    menuBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        topBar.classList.toggle('expanded');
                    });
                }

                mapElement.addEventListener('click', closeMenu);
            };
        });
    </script>
</body>

</html>